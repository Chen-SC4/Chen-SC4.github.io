<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>4. 子序列宽度之和</title>
    <link href="/2022/11/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%A2%98/4.%20%E5%AD%90%E5%BA%8F%E5%88%97%E5%AE%BD%E5%BA%A6%E4%B9%8B%E5%92%8C/"/>
    <url>/2022/11/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%A2%98/4.%20%E5%AD%90%E5%BA%8F%E5%88%97%E5%AE%BD%E5%BA%A6%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="子序列宽度之和"><ahref="https://leetcode.cn/problems/sum-of-subsequence-widths/">子序列宽度之和</a></h2><blockquote><p>先对数组进行排序，然后求出每个元素对于最后结果的<strong>贡献值</strong>。假设排序后的元素为<code>[0, 1, 2, 3, 4, 5]</code>。现在求元素<code>2</code>的贡献值：</p><ul><li>以2为最大值的子序列的个数为<span class="math inline">\(2^2 =4\)</span>个，即对于[0,1]中的元素，每个元素都有选和不选两种方案，故一共有<spanclass="math inline">\(2^2 =4\)</span>种组合，假设在这些子序列中，最小值为<spanclass="math inline">\(X_i\)</span>。</li><li>同理，以2为最小值的子序列个数为<span class="math inline">\(2^3 =8\)</span>个，假设在这些子序列中，最大值为<spanclass="math inline">\(Y_i\)</span>。</li><li>则有</li></ul><p><span class="math display">\[(2 - X_i) \times 2^2 + (Y_i - 2) \times 2^3\]</span></p><ul><li>故元素2的总贡献为<span class="math inline">\((2^3 - 2^2) \times2\)</span>。</li><li>其他元素同理，最后的结果就是所有元素的贡献之和。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000000007</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumSubseqWidths</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Arrays.sort(nums);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0L</span>;<br>        <span class="hljs-comment">// 为了方便起见，专门用一个数组来存储2的幂次方</span><br>        <span class="hljs-type">long</span>[] pow = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[length];<br>        pow[<span class="hljs-number">0</span>] = <span class="hljs-number">1L</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; length; ++i) &#123;<br>            pow[i] = (pow[i - <span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-number">1</span>) % MOD;<br>        &#125;<br><br>        <span class="hljs-comment">// nums[i] * (pow[i] - pow[length - 1 - i])就是在求第i个元素的贡献值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; ++i) &#123;<br>            result = (result + (nums[i] * (pow[i] - pow[length - <span class="hljs-number">1</span> - i]) % MOD)) % MOD;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3. 特殊的二进制序列</title>
    <link href="/2022/08/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%A2%98/3.%20%E7%89%B9%E6%AE%8A%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%BA%8F%E5%88%97/"/>
    <url>/2022/08/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%A2%98/3.%20%E7%89%B9%E6%AE%8A%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="特殊的二进制序列"><ahref="https://leetcode.cn/problems/special-binary-string/">特殊的二进制序列</a></h2><blockquote><p>将<code>1</code>看成左括号<code>(</code>，将<code>0</code>看成右括号<code>)</code>。</p><p>本题的二进制序列性质：</p><ul><li><code>0</code>的数量与<code>1</code>的数量相等 -左括号与右括号数量相等</li><li>二进制序列的每一个前缀码中<code>1</code>的数量要大于<code>0</code>的数量- 括号序列合法 (即不会出现<code>)(</code> 的情况)</li></ul><p>本题的要求就是相邻的两个括号可以交换位置，保证最后的括号序列中<code>(</code>的位置尽量靠前。</p><p>可以使用递归来实现：</p><ul><li>对于一对括号<code>(...)</code>，若括号中没有其他括号，则直接返回<code>"()"</code></li><li>若括号中有其他括号，则将括号挑选出来，进行排序(排序规则为更多的左括号靠前的优先级更高)</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">makeLargestSpecial</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> s.length();<br>        <span class="hljs-keyword">return</span> DFS(s, <span class="hljs-number">0</span>, length);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">DFS</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-keyword">if</span> (start &gt;= end) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> start, count = <span class="hljs-number">0</span>;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; end; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (s.charAt(i) == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                ++count;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                --count;<br>                <span class="hljs-comment">// 挑选出括号</span><br>                <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123;<br>                    list.add(<span class="hljs-string">&quot;1&quot;</span> + DFS(s, prev + <span class="hljs-number">1</span>, i) + <span class="hljs-string">&quot;0&quot;</span>);<br>                    prev = i + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 排序</span><br>        list.sort((<span class="hljs-keyword">var</span> a, <span class="hljs-keyword">var</span> b) -&gt; &#123;<br>            <span class="hljs-keyword">return</span> b.compareTo(a);<br>        &#125;);<br>        <span class="hljs-keyword">return</span> String.join(<span class="hljs-string">&quot;&quot;</span>, list);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2. 合并K个升序链表</title>
    <link href="/2022/08/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%A2%98/2.%20%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/08/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%A2%98/2.%20%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="合并k个升序链表"><ahref="https://leetcode.cn/problems/merge-k-sorted-lists/">合并K个升序链表</a></h2><blockquote><p>多路归并问题。通常使用优先队列(堆)来解决问题。</p><p>大致思路为：</p><ol type="1"><li>先将<code>k</code>个升序链表中的第一个元素放入堆中，由于堆的特性，在堆顶的元素一定就是最小的那个元素</li><li>将堆顶的元素<code>node</code>取出，将<code>node</code>插入结果链表的尾部，将该元素所在链表的下一个元素<code>node.next</code>放入堆中，如果没有下一个元素就不放入</li><li>重复步骤<code>2</code>，直到堆为空</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> &#123;<br>        PriorityQueue&lt;ListNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((<span class="hljs-keyword">var</span> a, <span class="hljs-keyword">var</span> b) -&gt; &#123;<br>            <span class="hljs-keyword">return</span> a.val - b.val;<br>        &#125;);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">resultNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummyNode</span> <span class="hljs-operator">=</span> resultNode;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> node : lists) &#123;<br>            <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">continue</span>;<br>            queue.add(node);<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">poll</span> <span class="hljs-operator">=</span> queue.poll();<br>            dummyNode.next = poll;<br>            dummyNode = dummyNode.next;<br>            <span class="hljs-keyword">if</span> (poll.next != <span class="hljs-literal">null</span>) &#123;<br>                queue.add(poll.next);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> resultNode.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多路归并</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1. 寻找两个正序数组的中位数</title>
    <link href="/2022/08/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%A2%98/1-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <url>/2022/08/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%A2%98/1-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="寻找两个正序数组的中位数"><ahref="https://leetcode.cn/problems/median-of-two-sorted-arrays/">寻找两个正序数组的中位数</a></h2><blockquote><p>解法一：双指针。</p><p>使用双指针算法合并两个有序数组，然后根据数组长度找出中位数即可。</p><p>时间复杂度： <span class="math display">\[O(m + n)\]</span></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length1</span> <span class="hljs-operator">=</span> nums1.length, length2 = nums2.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length3</span> <span class="hljs-operator">=</span> length1 + length2;<br>        <span class="hljs-comment">// 合并之后的数组</span><br>        <span class="hljs-type">int</span>[] merge = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[length3];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, index = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 合并</span><br>        <span class="hljs-keyword">while</span> (i &lt; length1 &amp;&amp; j &lt; length2) &#123;<br>            <span class="hljs-keyword">if</span> (nums1[i] &lt; nums2[j]) &#123;<br>                merge[index++] = nums1[i++];<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                merge[index++] = nums2[j++];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (i &lt; length1) &#123;<br>            merge[index++] = nums1[i++];<br>        &#125;<br>        <span class="hljs-keyword">while</span> (j &lt; length2) &#123;<br>            merge[index++] = nums2[j++];<br>        &#125;<br>        <span class="hljs-comment">// 寻找中位数</span><br>        <span class="hljs-keyword">if</span> (length3 == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0.0D</span>;<br>        <span class="hljs-keyword">if</span> (length3 % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> (merge[(length3 - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>] * <span class="hljs-number">1.0D</span> + merge[(length3 - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] * <span class="hljs-number">1.0D</span>) / <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> merge[length3 / <span class="hljs-number">2</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>解法二：二分查找。</p><p>由于题目额外要求算法的时间复杂度应当是<spanclass="math inline">\(O(\log (m +n))\)</span>，所以可以猜测应当使用二分查找算法来解题。</p><p>假设两个数组的长度之和为<code>total</code>，原问题可以等效为：从两个有序数组中找到第<code>k</code>小的数。</p><ol type="1"><li>total为奇数：找到第<code>(total / 2 + 1)</code>小的数。</li><li>total为偶数：找到第<code>(total / 2)</code>和第<code>(total / 2 + 1)</code>小的数。</li></ol><p>具体思路为：</p><ul><li><p><code>find(int[] nums1, int[] nums2, int idx1, int idx2, int k)</code>表示<code>find(第一个数组, 第二个数组, 从第一个数组的idx1处开始寻找, 从第二个数组的idx2处开始寻找, 寻找第k小的数)</code></p></li><li><p>假设第一个数组的有效长度小于第二个数组。</p></li><li><p>第一个数组找前<code>k / 2</code>个数，第二个数组找前<code>k - k / 2</code>个数(为了确保k为奇数时的正确性)</p></li><li><p>假设<code>[idx1, next1 - 1]</code>是第一个数组的前<code>k / 2</code>个数，<code>[idx2, next2 - 1]</code>是第二个数组的前<code>k - k / 2</code>个数。</p></li><li><p>若<code>nums1[next1 - 1] &lt; nums2[next2 - 1]</code>，说明<code>nums1</code>的这前<code>k / 2</code>个数一定在整体的前<code>k</code>个数中，可以使得<code>idx1 = next1; k = k - (next1 - idx1)</code>，同时进行下一次查找。</p></li><li><p>若<code>nums2[next2 - 1] &lt; nums1[next1 - 1]</code>，说明<code>nums2</code>的这前<code>k - k / 2</code>个数一定在整体的前<code>k</code>个数中，可以使得<code>idx2 = next2; k = k - (next2 - idx2)</code>，同时进行下一次查找。</p></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> nums1.length + nums2.length;<br>        <span class="hljs-keyword">if</span> ((length &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> findK(nums1, nums2, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, length / <span class="hljs-number">2</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> findK(nums1, nums2, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, length / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span> (left + right) / <span class="hljs-number">2D</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> findK(nums1, nums2, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, length / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findK</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr1, <span class="hljs-type">int</span>[] arr2, <span class="hljs-type">int</span> index1, <span class="hljs-type">int</span> index2, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length1</span> <span class="hljs-operator">=</span> arr1.length, length2 = arr2.length;<br>        <span class="hljs-comment">// 保证第一个数组的有效长度始终小于等于第二个数组的有效长度</span><br>        <span class="hljs-keyword">if</span> (length1 - index1 &gt; length2 - index2) <br>            <span class="hljs-keyword">return</span> findK(arr2, arr1, index2, index1, k);<br>        <span class="hljs-comment">// 第一个数组中的所有元素已经检查完了, 直接返回第二个数组中的第k小的元素即可。</span><br>        <span class="hljs-keyword">if</span> (index1 &gt;= length1) <span class="hljs-keyword">return</span> arr2[index2 + k - <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 寻找最小的元素, 即两个数组的第一个元素中的最小值</span><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> Math.min(arr1[index1], arr2[index2]);<br>        &#125;<br>        <span class="hljs-comment">// 计算第k / 2小的元素的位置, 同时第一个数组需要保证不越界</span><br>        <span class="hljs-comment">// 计算第k - k / 2小的元素的位置，由于是中位数，所以较大的那个数组一定不会越界</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">next1</span> <span class="hljs-operator">=</span> Math.min(index1 + (k / <span class="hljs-number">2</span>), length1), next2 = index2 + k - (k / <span class="hljs-number">2</span>);<br>        <span class="hljs-comment">// 递归调用</span><br>        <span class="hljs-keyword">if</span> (arr1[next1 - <span class="hljs-number">1</span>] &gt; arr2[next2 - <span class="hljs-number">1</span>]) &#123;<br>            <span class="hljs-keyword">return</span> findK(arr1, arr2, index1, next2, k - next2 + index2);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> findK(arr1, arr2, next1, index2, k - next1 + index1);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>算法题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>循环队列简述</title>
    <link href="/2022/08/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E7%AE%80%E8%BF%B0/"/>
    <url>/2022/08/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E7%AE%80%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="循环队列"><ahref="https://leetcode.cn/problems/design-circular-queue/">循环队列</a></h2><p>循环队列是一种基于数组实现的队列。它的添加和删除操作的时间复杂度都为O(1)。</p><p>如果是基于数组实现的普通队列，它的删除操作的时间复杂度为O(1)，而添加操作就会涉及到数组的移动，其时间复杂度为O(n)。</p><h2 id="循环队列的实现">循环队列的实现</h2><p>为了减少边界的讨论，在实现循环队列的时候，为尾节点添加哨兵。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCircularQueue</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] queue;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> head;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> tail;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyCircularQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-comment">// 多出来的一个空位表示尾节点</span><br>        <span class="hljs-built_in">this</span>.size = k + <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">this</span>.queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-built_in">this</span>.size];<br>        <span class="hljs-built_in">this</span>.head = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.tail = <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 向队列尾部添加元素 如果队列已满 返回false 否则 返回true</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">enQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.isFull()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-built_in">this</span>.queue[<span class="hljs-built_in">this</span>.tail] = value;<br>        <span class="hljs-built_in">this</span>.tail = (<span class="hljs-built_in">this</span>.tail + <span class="hljs-number">1</span>) % <span class="hljs-built_in">this</span>.size;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 从队列头部删除元素 如果队列为空 返回false 否则 返回true</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">deQueue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-built_in">this</span>.head = (<span class="hljs-built_in">this</span>.head + <span class="hljs-number">1</span>) % <span class="hljs-built_in">this</span>.size;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 返回队列头部的元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">Front</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.isEmpty()) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.queue[<span class="hljs-built_in">this</span>.head];<br>    &#125;<br>    <br>    <span class="hljs-comment">// 返回队列尾部的元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">Rear</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.isEmpty()) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.queue[(<span class="hljs-built_in">this</span>.size + <span class="hljs-built_in">this</span>.tail - <span class="hljs-number">1</span>) % <span class="hljs-built_in">this</span>.size];<br>    &#125;<br>    <br>    <span class="hljs-comment">// 判断队列是否为空</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.head == <span class="hljs-built_in">this</span>.tail;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 判断队列是否已满</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> ((<span class="hljs-built_in">this</span>.tail + <span class="hljs-number">1</span>) % <span class="hljs-built_in">this</span>.size == <span class="hljs-built_in">this</span>.head);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>循环队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第304场周赛 Leetcode</title>
    <link href="/2022/07/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%AF%94%E8%B5%9B/%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B-Leetcode/"/>
    <url>/2022/07/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%AF%94%E8%B5%9B/%E7%AC%AC304%E5%9C%BA%E5%91%A8%E8%B5%9B-Leetcode/</url>
    
    <content type="html"><![CDATA[<h2 id="使数组中所有元素都等于零">1. <ahref="https://leetcode.cn/problems/make-array-zero-by-subtracting-equal-amounts/">使数组中所有元素都等于零</a></h2><p>贪心算法，每次都减去数组中最小的那个元素，这样每次都能保证去除至少一个元素。</p><p>只需要统计<code>num</code>中有多少种值即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumOperations</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Set&lt;Integer&gt; hashSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : nums) &#123;<br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            hashSet.add(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> hashSet.size();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="分组的最大数量">2. <ahref="https://leetcode.cn/problems/maximum-number-of-groups-entering-a-competition/">分组的最大数量</a></h2><p>脑筋急转弯。根据贪心算法，想要形成的分组数目最多，那么应该给第一组分一个元素，第二组分两个元素，第三组分三个元素……</p><p>现在的问题就是说明这样的分法一定能符合题目的要求一(这种分法必然符合要求二)。</p><blockquote><p>事实上，先将数组<code>grades</code>从小到大排序，然后再进行分组，就会发现每组一定符合要求。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumGroups</span><span class="hljs-params">(<span class="hljs-type">int</span>[] _grades)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> _grades.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (length &gt;= time) &#123;<br>            length = length - time;<br>            ++result;<br>            ++time;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="找到离给定两个节点最近的节点">3. <ahref="https://leetcode.cn/problems/find-closest-node-to-given-two-nodes/">找到离给定两个节点最近的节点</a></h2><p>寻找最短路径类的问题。由于每个节点只有一出度，所以这里使用的简单版的<code>Dijkstra</code>算法。</p><p>使用优先队列维护结果集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">closestMeetingNode</span><span class="hljs-params">(<span class="hljs-type">int</span>[] edges, <span class="hljs-type">int</span> node1, <span class="hljs-type">int</span> node2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node1 == node2) <span class="hljs-keyword">return</span> node1;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> edges.length;<br>        <span class="hljs-type">int</span>[] node1Visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[length], node2Visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[length];<br>        Arrays.fill(node1Visited, -<span class="hljs-number">1</span>);<br>        Arrays.fill(node2Visited, -<span class="hljs-number">1</span>);<br>        node1Visited[node1] = <span class="hljs-number">0</span>;<br>        node2Visited[node2] = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">node1Steps</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, node2Steps = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isNode1End</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>, isNode2End = <span class="hljs-literal">false</span>;<br>        PriorityQueue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span>[] b) -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (a[<span class="hljs-number">1</span>] != b[<span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>];<br>        &#125;);<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">if</span> (node1 == -<span class="hljs-number">1</span>) isNode1End = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (!isNode1End) &#123;<br>                node1 = edges[node1];<br>                <span class="hljs-keyword">if</span> (node1 != -<span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (node1Visited[node1] != -<span class="hljs-number">1</span>) &#123;<br>                        isNode1End = <span class="hljs-literal">true</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (node2Visited[node1] != -<span class="hljs-number">1</span>) &#123;<br>                        queue.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;node1, Math.max(node2Visited[node1], node1Steps)&#125;);<br>                    &#125;<br>                    node1Visited[node1] = node1Steps++;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (node2 == -<span class="hljs-number">1</span>) isNode2End = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (!isNode2End) &#123;<br>                node2 = edges[node2];<br>                <span class="hljs-keyword">if</span> (node2 != -<span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (node2Visited[node2] != -<span class="hljs-number">1</span>) &#123;<br>                        isNode2End = <span class="hljs-literal">true</span>;<br>                    &#125;<br>        <br>                    <span class="hljs-keyword">if</span> (node1Visited[node2] != -<span class="hljs-number">1</span>) &#123;<br>                        queue.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;node2, Math.max(node2Steps, node1Visited[node2])&#125;);<br>                    &#125;<br>                    node2Visited[node2] = node2Steps++;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (isNode1End &amp;&amp; isNode2End) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> queue.isEmpty() ? -<span class="hljs-number">1</span> : queue.peek()[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="图中的最长环">4. <ahref="https://leetcode.cn/problems/longest-cycle-in-a-graph/">图中的最长环</a></h2><p>每次访问到一个节点时，存储该节点的键值以及访问到该节点时已经走过的步数，当再次访问到该节点时，就说明存在环，<code>当前步数 - 第一次访问该节点时的步数</code>就是环的长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestCycle</span><span class="hljs-params">(<span class="hljs-type">int</span>[] edges)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> edges.length;<br>        Set&lt;Integer&gt; visitedPoints = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (!visitedPoints.contains(i)) &#123;<br>                Map&lt;Integer, Integer&gt; point_Steps = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> i, steps = <span class="hljs-number">0</span>;<br>                <span class="hljs-type">boolean</span> <span class="hljs-variable">noCircle</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">while</span> (!point_Steps.containsKey(dummy)) &#123;<br>                    point_Steps.put(dummy, steps++);<br>                    dummy = edges[dummy];<br>                    <span class="hljs-keyword">if</span> (visitedPoints.contains(dummy)) &#123;<br>                        point_Steps.put(dummy, steps);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (dummy == -<span class="hljs-number">1</span>) &#123;<br>                        noCircle = <span class="hljs-literal">true</span>;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (point_Steps.isEmpty()) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span> (noCircle) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key : point_Steps.keySet()) &#123;<br>                        visitedPoints.add(key);<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key : point_Steps.keySet()) &#123;<br>                        visitedPoints.add(key);<br>                    &#125;<br>                    result = Math.max(result, steps - point_Steps.get(dummy));<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">return</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span>= <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span> : result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>比赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode 周赛</tag>
      
      <tag>贪心算法</tag>
      
      <tag>Dijkstra算法</tag>
      
      <tag>广度优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跳表简述</title>
    <link href="/2022/07/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E8%B7%B3%E8%A1%A8/"/>
    <url>/2022/07/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E8%B7%B3%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="单向链表">单向链表</h2><p>单向链表的特点是插入与删除非常高效。但是对于查找链表中的第<code>i</code>个元素这样的操作，必须要从链表头节点开始往后依次查询。时间复杂度为O(n)。</p><p>当链表长度较长时，普通的单向链表的查询就会变得非常低效了。</p><p><img src="https://cdn.jsdelivr.net/gh/Chen-SC4/HexoImages/20220729215040.png" alt="单向链表" style="zoom:80%;" /></p><h2 id="跳表">跳表</h2><p>为了加快查找速度，可以为这个单向链表添加一个索引。</p><p><img src="https://cdn.jsdelivr.net/gh/Chen-SC4/HexoImages/20220729215530.png" alt="二级索引" style="zoom:80%;" /></p><p>当查找某个元素时，先在上面的索引层中查找，找到对应的索引之后，再查找具体的节点。</p><p>随着元素的增加，可以添加第二级索引，甚至更高级的索引。</p><p><img src="https://cdn.jsdelivr.net/gh/Chen-SC4/HexoImages/20220729220125.png" alt="高级索引" style="zoom:80%;" /></p><p>例如，查找元素<code>8</code>时，先从<code>3</code>级索引<code>1</code>处开始查找：</p><ul><li>下一个元素为<code>9</code>，<code>9 &gt; 8</code>，所以目标元素在<code>9</code>之前，向下进入<code>2</code>级索引</li><li>下一个元素为<code>5</code>，<code>5 &lt; 8</code>，所以目标元素在<code>5</code>之后，当前索引值切换为<code>5</code></li><li>下一个元素为<code>9</code>，<code>9 &gt; 8</code>，向下进入<code>1</code>级索引</li><li>下一个元素为<code>7</code>，<code>7 &lt; 8</code>，当前索引值切换为<code>7</code></li><li>下一个元素为<code>9</code>，<code>9 &gt; 8</code>，向下进入<code>0</code>级索引</li><li>下一个元素为<code>8</code>，找到目标元素</li></ul><p>在实际实现中，为了减少边界的处理，可以引入头节点。</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/Chen-SC4/HexoImages/20220729221155.png"alt="跳表加入头节点" /><figcaption aria-hidden="true">跳表加入头节点</figcaption></figure><hr /><p>在示例中，索引的分布是均匀的；但是在实际使用的过程中，由于需要不断地进行插入与删除，想要维护索引的均匀分布是比较困难的。</p><p>事实上，在跳表中，哪个元素具有多少层索引是在插入该元素的时候，随机决定的。更具体的说，每个元素在插入时100%具有0级索引，50%具有1级索引，25%具有2级索引……</p><p>通过随机的方式，在插入大量的数据时，可以保证1级索引的数目为0级索引数目的50%、2级索引的数目为1级索引数目的50%……这个比率就是元素生成索引的晋升概率<code>FACTOR</code>。</p><p>关于生成索引的概率因子<code>FACTOR</code>：如果我们想要节约空间，使索引变少，那么可以适当的下调<code>FACTOR</code>；反之，如果我们想增加索引的个数，则可以适当的上调<code>FACTOR</code>。</p><h3 id="添加">添加</h3><p>类似于单向链表的添加操作，我们首先需要找到待插入位置的前驱节点<code>prev</code>，然后<code>insertNode.next = prev.next</code>，再<code>prev.next = insertNode</code>即可。</p><p>在跳表中，需要插入的位置有多个，所以我们需要先找到这些位置的前驱节点。假设现在要插入的节点值为<code>6.5</code>。那么需要更新的节点为1、5、5、6这四个节点。</p><p><img src="https://cdn.jsdelivr.net/gh/Chen-SC4/HexoImages/20220729223925.png" alt="待更新节点" style="zoom:80%;" /></p><p>然后通过随机数生成算法，生成<code>6.5</code>的索引数目(假设跳表中的索引数目最大为4、6.5的索引数目为3)，再从0级索引开始向上进行更新。</p><p><img src="https://cdn.jsdelivr.net/gh/Chen-SC4/HexoImages/20220729224430.png" alt="添加节点" style="zoom:80%;" /></p><h3 id="删除">删除</h3><p>删除操作与添加操作类似，也需要先找出待更新的前驱节点，然后之后再统一的进行更新操作。</p><p>不过，不一样的是，删除操作在进行删除操作前，需要检查待删除的节点是否在跳表中。这个只需要检查第<code>0</code>级索引的待更新的节点的后继节点是否是需要删除的节点就行了。</p><h2 id="实现">实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SkipList</span> &#123;<br>    <span class="hljs-comment">// 跳表中的最大索引层数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_LEVEL</span> <span class="hljs-operator">=</span> <span class="hljs-number">32</span>;<br>    <span class="hljs-comment">// 拥有第一级索引的概率(因子)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> <span class="hljs-variable">FACTOR</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.5</span>;<br><br>    <span class="hljs-comment">// 跳表根节点</span><br>    <span class="hljs-keyword">private</span> SkipNode root;<br>    <span class="hljs-comment">// 当前的最大层数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> currentLevel;<br>    <span class="hljs-comment">// 随机数生成器</span><br>    <span class="hljs-keyword">private</span> Random random;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SkipList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SkipNode</span>(<span class="hljs-number">0</span>, SkipList.MAX_LEVEL);<br>        <span class="hljs-built_in">this</span>.currentLevel = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.random = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 查找操作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">SkipNode</span> <span class="hljs-variable">dummyNode</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.currentLevel - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; ++i) &#123;<br>            <span class="hljs-keyword">while</span> (dummyNode.nodeList[i] != <span class="hljs-literal">null</span> &amp;&amp; dummyNode.nodeList[i].value &lt; target) &#123;<br>                dummyNode = dummyNode.nodeList[i];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (dummyNode.nodeList[<span class="hljs-number">0</span>] == <span class="hljs-literal">null</span> || dummyNode.nodeList[<span class="hljs-number">0</span>].value != target) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 添加操作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        <span class="hljs-comment">// 待更新的前驱节点数组</span><br>        SkipNode[] readyToUpdate = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SkipNode</span>[SkipList.MAX_LEVEL];<br>        Arrays.fill(readyToUpdate, <span class="hljs-built_in">this</span>.root);<br>        <span class="hljs-type">SkipNode</span> <span class="hljs-variable">dummyNode</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.currentLevel - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-keyword">while</span> (dummyNode.nodeList[i] != <span class="hljs-literal">null</span> &amp;&amp; dummyNode.nodeList[i].value &lt; num) &#123;<br>                dummyNode = dummyNode.nodeList[i];<br>            &#125;<br>            readyToUpdate[i] = dummyNode;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numLevel</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getRandomLevel();<br>        <span class="hljs-type">SkipNode</span> <span class="hljs-variable">insertNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SkipNode</span>(num, numLevel);<br>        <span class="hljs-built_in">this</span>.currentLevel = Math.max(<span class="hljs-built_in">this</span>.currentLevel, numLevel);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numLevel; ++i) &#123;<br>            insertNode.nodeList[i] = readyToUpdate[i].nodeList[i];<br>            readyToUpdate[i].nodeList[i] = insertNode;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 删除操作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">erase</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>        SkipNode[] readyToUpdate = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SkipNode</span>[SkipList.MAX_LEVEL];<br>        <span class="hljs-type">SkipNode</span> <span class="hljs-variable">dummyNode</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.currentLevel - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-keyword">while</span> (dummyNode.nodeList[i] != <span class="hljs-literal">null</span> &amp;&amp; dummyNode.nodeList[i].value &lt; num) &#123;<br>                dummyNode = dummyNode.nodeList[i];<br>            &#125;<br>            readyToUpdate[i] = dummyNode;<br>        &#125;<br>        dummyNode = readyToUpdate[<span class="hljs-number">0</span>].nodeList[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span> (dummyNode == <span class="hljs-literal">null</span> || dummyNode.value != num) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.currentLevel; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (readyToUpdate[i].nodeList[i] != dummyNode) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            readyToUpdate[i].nodeList[i] = readyToUpdate[i].nodeList[i].nodeList[i];<br>        &#125;<br>        <span class="hljs-comment">// 更新当前的最大层数</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">this</span>.currentLevel &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">this</span>.root.nodeList[<span class="hljs-built_in">this</span>.currentLevel - <span class="hljs-number">1</span>] == <span class="hljs-literal">null</span>) &#123;<br>            --<span class="hljs-built_in">this</span>.currentLevel;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取随机索引层数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getRandomLevel</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">this</span>.random.nextDouble() &lt; SkipList.FACTOR &amp;&amp; result &lt; SkipList.MAX_LEVEL) &#123;<br>            ++result;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 跳表节点定义</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SkipNode</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> value;<br>    <span class="hljs-keyword">public</span> SkipNode[] nodeList;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SkipNode</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SkipNode</span><span class="hljs-params">(<span class="hljs-type">int</span> _value, <span class="hljs-type">int</span> size)</span> &#123;<br>        <span class="hljs-built_in">this</span>.value = _value;<br>        <span class="hljs-built_in">this</span>.nodeList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SkipNode</span>[size];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>跳表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第302场周赛 Leetcode</title>
    <link href="/2022/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%AF%94%E8%B5%9B/%E7%AC%AC302%E5%9C%BA%E5%91%A8%E8%B5%9B-Leetcode/"/>
    <url>/2022/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%AF%94%E8%B5%9B/%E7%AC%AC302%E5%9C%BA%E5%91%A8%E8%B5%9B-Leetcode/</url>
    
    <content type="html"><![CDATA[<h2 id="数组能形成多少数对">1. <ahref="https://leetcode.cn/problems/maximum-number-of-pairs-in-array/">数组能形成多少数对</a></h2><p>先将数组排序，然后用栈来判断相同数字。</p><p>如果当前数字与栈顶数字相同，则说明出现了一个数对，将栈顶元素出栈，并记录该数对。</p><p>如果当前数字与栈顶数字不同，则将当前数字入栈。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] numberOfPairs(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-comment">// 排序</span><br>        Arrays.sort(nums);<br>        <span class="hljs-comment">// 栈</span><br>        Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-comment">// answer0 -&gt; 数对数目</span><br>        <span class="hljs-comment">// answer1 -&gt; 剩余数字数目</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">answer0</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, answer1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i : nums) &#123;<br>            <span class="hljs-keyword">if</span> (stack.isEmpty()) &#123;<br>                stack.addLast(i);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-type">int</span> <span class="hljs-variable">poll</span> <span class="hljs-operator">=</span> stack.peekLast();<br>            <span class="hljs-keyword">if</span> (poll == i) &#123;<br>                stack.pollLast();<br>                ++answer0;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                stack.addLast(i);<br>            &#125;<br>        &#125;<br>        answer1 = stack.size();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;answer0, answer1&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数位和相等数对的最大和">2. <ahref="https://leetcode.cn/problems/max-sum-of-a-pair-with-equal-sum-of-digits/">数位和相等数对的最大和</a></h2><p>使用哈希表来记录某个数位和对应的两个最大数字。</p><p>结果就是哈希表中加和最大的那一组数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Map&lt;Integer, <span class="hljs-type">int</span>[]&gt; hashMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i : nums) &#123;<br>            <span class="hljs-comment">// 计算出当前数字的数位和</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> getBitsSum(i);<br>            <span class="hljs-keyword">if</span> (!hashMap.containsKey(key)) &#123;<br>                hashMap.put(key, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;-<span class="hljs-number">1</span>, i&#125;);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span>[] poll = hashMap.get(key);<br>                <span class="hljs-keyword">if</span> (poll[<span class="hljs-number">0</span>] == -<span class="hljs-number">1</span>) &#123;<br>                    poll[<span class="hljs-number">0</span>] = i &lt;= poll[<span class="hljs-number">1</span>] ? i : poll[<span class="hljs-number">1</span>];<br>                    poll[<span class="hljs-number">1</span>] = i &lt;= poll[<span class="hljs-number">1</span>] ? poll[<span class="hljs-number">1</span>] : i;<br>                    hashMap.put(key, poll);<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (poll[<span class="hljs-number">1</span>] &lt;= i) &#123;<br>                        poll[<span class="hljs-number">0</span>] = poll[<span class="hljs-number">1</span>];<br>                        poll[<span class="hljs-number">1</span>] = i;<br>                        hashMap.put(key, poll);<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> &#123;<br>                        poll[<span class="hljs-number">0</span>] = Math.max(poll[<span class="hljs-number">0</span>], i);<br>                        hashMap.put(key, poll);<br>                    &#125;<br>                &#125;<br>                result = Math.max(result, poll[<span class="hljs-number">0</span>] + poll[<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">// 统计数位和的函数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getBitsSum</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i != <span class="hljs-number">0</span>) &#123;<br>            result = result + (i % <span class="hljs-number">10</span>);<br>            i = i / <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="裁剪数字后查询第-k-小的数字">3. <ahref="https://leetcode.cn/problems/query-kth-smallest-trimmed-number/">裁剪数字后查询第K 小的数字</a></h2><p>先将所有可能的排序组合进行预处理，然后对于每一种<code>queries</code>直接返回结果即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] smallestTrimmedNumbers(String[] nums, <span class="hljs-type">int</span>[][] queries) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>].length();<br>        <span class="hljs-comment">// 存放预处理结果的数组</span><br>        <span class="hljs-comment">// 用Integer是因为Java中对基础类型的自定义排序支持的不是很好 需要装箱</span><br>        Integer[][] grid = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[length][nums.length];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length, n = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[] resultArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[queries.length];<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-comment">// 先将下标初始化</span><br>                grid[i][j] = j;<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-comment">// 针对下标的自定义排序</span><br>            Arrays.sort(grid[i], (Integer a, Integer b) -&gt; &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">strA</span> <span class="hljs-operator">=</span> nums[a], strB = nums[b];<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> length - <span class="hljs-number">1</span> - temp; s &lt; length; ++s) &#123;<br>                    <span class="hljs-type">char</span> <span class="hljs-variable">charA</span> <span class="hljs-operator">=</span> strA.charAt(s), charB = strB.charAt(s);<br>                    <span class="hljs-keyword">if</span> (charA != charB) &#123;<br>                        <span class="hljs-keyword">return</span> charA - charB;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;);<br>        &#125;<br>        <span class="hljs-comment">// 处理queries结果</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; queries.length; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> queries[i][<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>, trimCount = queries[i][<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>;<br>            resultArray[i] = grid[trimCount][k];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> resultArray;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使数组可以被整除的最少删除次数">4. <ahref="https://leetcode.cn/problems/minimum-deletions-to-make-array-divisible/">使数组可以被整除的最少删除次数</a></h2><p>先使用<code>Set</code>对<code>numsDivide</code>进行去重，然后求出<code>numsDivide</code>中所有元素的最大公约数<code>divideNum</code>。</p><p>之后对<code>nums</code>数组进行从小到大排序，然后从头遍历<code>nums</code>数组，如果某个元素<code>i</code>满足<code>divideNum % i == 0</code>，则说明该数即为可以整除<code>numsDivide</code>中所有元素的数。将该元素下标之前的数全部删除即可，所以，结果就是该元素的下标。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minOperations</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span>[] numsDivide)</span> &#123;<br>        Set&lt;Integer&gt; divideSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-comment">// 使用Set去重</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : numsDivide) &#123;<br>            divideSet.add(i);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">divideNum</span> <span class="hljs-operator">=</span> numsDivide[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">// 求最大公约数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : divideSet) &#123;<br>            divideNum = GCD(divideNum, i);<br>        &#125;<br><br>        Arrays.sort(nums);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (divideNum % nums[i] == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">return</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">GCD</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> a;<br>        <span class="hljs-keyword">return</span> GCD(b, a % b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>比赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode 周赛</tag>
      
      <tag>栈</tag>
      
      <tag>自定义排序</tag>
      
      <tag>哈希表</tag>
      
      <tag>最大公约数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第82场双周赛 Leetcode</title>
    <link href="/2022/07/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%AF%94%E8%B5%9B/%E7%AC%AC82%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B-Leetcode/"/>
    <url>/2022/07/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%AF%94%E8%B5%9B/%E7%AC%AC82%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B-Leetcode/</url>
    
    <content type="html"><![CDATA[<h2 id="计算布尔二叉树的值">1. <ahref="https://leetcode.cn/problems/evaluate-boolean-binary-tree/">计算布尔二叉树的值</a></h2><p>简单递归题，根据题意模拟即可，不过作为周赛签到题，比以往难了一些。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">evaluateTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root.val == <span class="hljs-number">0</span> || root.val == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> root.val == <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (root.val == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> evaluateTree(root.left) || evaluateTree(root.right);<br>        <span class="hljs-keyword">return</span> evaluateTree(root.left) &amp;&amp; evaluateTree(root.right); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="坐上公交的最晚时间">2. <ahref="https://leetcode.cn/problems/the-latest-time-to-catch-a-bus/">坐上公交的最晚时间</a></h2><p>本题作为第二题，难度极高。</p><p>基本思路是，先将公交车以及乘客到达的事件排序，然后使用双指针算法模拟出乘客乘坐公交的情况。</p><p>之后再对不同的情况进行分类：</p><ul><li>最后一辆公交车没有人或者人没有坐满，则<code>result</code>直接从最后一辆公交车的发车时间开始计算，检查改时间有没有与某个乘客重合，如果重合则<code>--result</code>，否则<code>return result</code></li><li>则<code>result</code>从最后一辆公交的最后一名乘客的乘车时间减一开始计算，然后检查时间有没有某个乘客重合，如果重合则<code>--result</code>，否则<code>return result</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">latestTimeCatchTheBus</span><span class="hljs-params">(<span class="hljs-type">int</span>[] buses, <span class="hljs-type">int</span>[] passengers, <span class="hljs-type">int</span> capacity)</span> &#123;<br>        Arrays.sort(buses);<br>        Arrays.sort(passengers);<br>        List&lt;List&lt;Integer&gt;&gt; passengersList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">busesIdx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, passengersIdx = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> buses.length, m = passengers.length;<br>        <span class="hljs-comment">// 双指针算法 模拟乘客乘车</span><br>        <span class="hljs-keyword">while</span> (busesIdx &lt; n &amp;&amp; passengersIdx &lt; m) &#123;<br>            List&lt;Integer&gt; currPass = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; capacity; ++i) &#123;<br>                <span class="hljs-keyword">if</span> (passengersIdx &lt; m &amp;&amp; passengers[passengersIdx] &lt;= buses[busesIdx]) &#123;<br>                    currPass.add(passengers[passengersIdx++]);<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>            &#125;<br>            passengersList.add(currPass);<br>            ++busesIdx;<br>        &#125;<br><br>        <span class="hljs-comment">// 求result</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">mainLength</span> <span class="hljs-operator">=</span> passengersList.size();<br>        <span class="hljs-keyword">if</span> (busesIdx &lt; n) <span class="hljs-keyword">return</span> buses[n - <span class="hljs-number">1</span>];<br>        List&lt;Integer&gt; lastBuses = passengersList.get(mainLength - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (lastBuses.size() &gt;= capacity) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> lastBuses.get(lastBuses.size() - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> m - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; --j) &#123;<br>                <span class="hljs-keyword">if</span> (result &lt; passengers[j]) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span> (result == passengers[j]) --result;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> result;<br>            &#125;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> buses[n - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (lastBuses.isEmpty() || result &gt; lastBuses.get(lastBuses.size() - <span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> result;<br>            result = lastBuses.get(lastBuses.size() - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> m - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; --j) &#123;<br>                <span class="hljs-keyword">if</span> (result &lt; passengers[j]) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span> (result == passengers[j]) --result;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> result;<br>            &#125;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="最小差值平方和">3. <ahref="https://leetcode.cn/problems/minimum-sum-of-squared-difference/">最小差值平方和</a></h2><p>将<code>nums1</code>或<code>nums2</code>中的元素进行<code>+1</code>或<code>-1</code>操作，实际上就是对它们的差值进行操作递增或递减操作。而本题是要求最小差值平方和，所以我们可以只考虑它们的差值组成的数组。</p><p>题目就变为了，给一个数组<code>Arr</code>，通过<code>k</code>的递减操作，使得数组的各元素平方和最小。</p><p>想要使得平方和最小，我们每次当然需要对数组中最大的元素进行递减操作，如果有多个最大的元素，则需要同时将它们减小。利用这个特性，我们可以先直接将最大元素减小成与第二大的元素相等，然后这两个元素就是最大的，我们再同时减小这两个元素，直到与第三大的元素相等...</p><p>一直这样操作，直到<code>k</code>次递减数目用完，或者数组中的元素全为<code>0</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">minSumSquareDiff</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span> k1, <span class="hljs-type">int</span> k2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums1.length, k = k1 + k2;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0L</span>;<br>        <span class="hljs-type">int</span>[] diffArr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-comment">// 求差值数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            diffArr[i] = Math.abs(nums1[i] - nums2[i]); <span class="hljs-comment">//4 4 5 9 10</span><br>        &#125;<br>        <span class="hljs-comment">// 对差值数组进行排序</span><br>        Arrays.sort(diffArr);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            sum = sum + diffArr[i];<br>        &#125;<br><br>        <span class="hljs-comment">// 计算可以减小到与第几个元素持平</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">currSum</span> <span class="hljs-operator">=</span> sum, index = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            currSum = currSum - diffArr[i + <span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">leftSum</span> <span class="hljs-operator">=</span> diffArr[i] * (n - i - <span class="hljs-number">1</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">dist</span> <span class="hljs-operator">=</span> sum - currSum - leftSum;<br>            <span class="hljs-keyword">if</span> (dist &gt;= k) &#123;<br>                index = i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (index == -<span class="hljs-number">1</span>) currSum = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index + <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            diffArr[i] = diffArr[index + <span class="hljs-number">1</span>];<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftK</span> <span class="hljs-operator">=</span> k - (sum - currSum - diffArr[index + <span class="hljs-number">1</span>] * (n - <span class="hljs-number">1</span> - index));<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">times</span> <span class="hljs-operator">=</span> leftK / (n - <span class="hljs-number">1</span> - index), mod = leftK % (n - <span class="hljs-number">1</span> - index);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index + <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt; n; ++i, ++j) &#123;<br>            <span class="hljs-keyword">if</span> (j &lt; mod) &#123;<br>                diffArr[i] = Math.max(<span class="hljs-number">0</span>, diffArr[i] - times - <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                diffArr[i] = Math.max(<span class="hljs-number">0</span>, diffArr[i] - times);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : diffArr) &#123;<br>            result = result + (i * <span class="hljs-number">1L</span> * i);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="元素值大于变化阈值的子数组">4. <ahref="https://leetcode.cn/problems/subarray-with-elements-greater-than-varying-threshold/">元素值大于变化阈值的子数组</a></h2><p>对于一个元素<code>nums[i]</code>，先假设它是某个区间内的最小元素，同时假设区间长度为<code>length</code>，则如果<code>nums[i] * length &gt; threshold</code>就说明我们找到了一个符合题目要求的子数组。</p><p>所以当前的问题就转换为了如何寻找这个区间。</p><p>由于之前的假设，<code>nums[i]</code>是区间内的最小元素，所以对于某一个元素<code>nums[i]</code>，我们只需要找到它左边的第一个小于它的元素的下标<code>a</code>，以及右边的第一个小于它的元素的下标<code>b</code>，则<code>b - a - 1</code>就是我们要找的区间的长度。</p><p>而求某个元素左侧或者右侧第一个大于(小于)该元素的其他元素的方法，通常使用的就是<strong>单调栈</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">validSubarraySize</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> threshold)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> nums.length;<br>        Deque&lt;<span class="hljs-type">int</span>[]&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span>[] leftIndex = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[length], rightIndex = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[length];<br>        <span class="hljs-comment">// 单调栈求右边第一个小于nums[i]的元素的下标</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (stack.isEmpty()) &#123;<br>                stack.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;nums[i], i&#125;);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>                <span class="hljs-type">int</span>[] poll = stack.peekLast();<br>                <span class="hljs-keyword">if</span> (poll[<span class="hljs-number">0</span>] &gt; nums[i]) &#123;<br>                    stack.pollLast();<br>                    rightIndex[poll[<span class="hljs-number">1</span>]] = i;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            stack.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;nums[i], i&#125;);<br>        &#125;<br>        <br>        <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] poll = stack.pollLast();<br>            rightIndex[poll[<span class="hljs-number">1</span>]] = length;<br>        &#125;<br><br>        <span class="hljs-comment">// 单调栈求左边第一个小于nums[i]的元素的下标</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-keyword">if</span> (stack.isEmpty()) &#123;<br>                stack.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;nums[i], i&#125;);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>                <span class="hljs-type">int</span>[] poll = stack.peekLast();<br>                <span class="hljs-keyword">if</span> (poll[<span class="hljs-number">0</span>] &gt; nums[i]) &#123;<br>                    stack.pollLast();<br>                    leftIndex[poll[<span class="hljs-number">1</span>]] = i;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            stack.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;nums[i], i&#125;);<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>            <span class="hljs-type">int</span>[] poll = stack.pollLast();<br>            leftIndex[poll[<span class="hljs-number">1</span>]] = -<span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">currentLength</span> <span class="hljs-operator">=</span> rightIndex[i] - leftIndex[i] - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (nums[i] * currentLength &gt; threshold) &#123;<br>                <span class="hljs-keyword">return</span> currentLength;<br>            &#125;<br>        &#125; <br><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>比赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode 双周赛</tag>
      
      <tag>模拟</tag>
      
      <tag>递归</tag>
      
      <tag>单调栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大端序与小端序简述</title>
    <link href="/2022/07/14/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%A4%A7%E7%AB%AF%E5%BA%8F%E4%B8%8E%E5%B0%8F%E7%AB%AF%E5%BA%8F%E7%AE%80%E8%BF%B0/"/>
    <url>/2022/07/14/%E8%80%83%E7%A0%94/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%A4%A7%E7%AB%AF%E5%BA%8F%E4%B8%8E%E5%B0%8F%E7%AB%AF%E5%BA%8F%E7%AE%80%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="字节序">字节序</h2><blockquote><p>字节顺序，又称端序或尾序（英语：Endianness），在计算机科学领域中，指电脑内存中或在数字通信链路中，组成多字节的字的字节的排列顺序。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[字节顺序-Wikipedia](https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F)">[1]</span></a></sup></p></blockquote><p>我们常说的大端序与小端序就是两种排列顺序。</p><h2 id="大端序与小端序">大端序与小端序</h2><p>大端序就是大头在前，将高位的字节放在低位的地址上，这样人在阅读时就会比较方便，因为从左到右阅读对应着地址从低到高，符合人们的阅读习惯。</p><p>小端序与大端序相反，将低位的字节放在低位的地址上，这样不利于人的阅读，但是利于计算机的运算操作，因为在四则运算中，需要从低位开始计算然后判断进位，之后算到高位。</p><p>下面的例子中，分别使用大端序存储和小端序存储来存储<code>0x1234 5678</code>。</p><center><table><thead><tr class="header"><th style="text-align: center;">0</th><th style="text-align: center;">1</th><th style="text-align: center;">2</th><th style="text-align: center;">3</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">0x12</td><td style="text-align: center;">0x34</td><td style="text-align: center;">0x56</td><td style="text-align: center;">0x78</td></tr></tbody></table><p><font face="楷体">大端序存储</font></p></center><center><table><thead><tr class="header"><th style="text-align: center;">0</th><th style="text-align: center;">1</th><th style="text-align: center;">2</th><th style="text-align: center;">3</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">0x78</td><td style="text-align: center;">0x56</td><td style="text-align: center;">0x34</td><td style="text-align: center;">0x12</td></tr></tbody></table><p><font face="楷体">小端序存储</font></p></center><p>例如检查奇偶性，在大端序中，计算机需要读到最后一位才知道时奇数还是偶数，然而在小端序中，计算机只用读第一位就知道了。</p><p>不过小端序并不总是对计算机友好，例如在判断正负号时，大端序就能在第一位判断出来，而小端序则需要读取到最后一位。</p><p>类似的运算还有很多，综合的看，小端序的存储顺序有利于四则运算这种逐位的运算，而大端存储方式有利于只针对于高位的计算，例如判断正负号等。</p><h2 id="参考资料">参考资料</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><ahref="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F">字节顺序-Wikipedia</a><a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><ahref="https://www.zhihu.com/question/25311159">知乎-大小端字节序存在的意义，为什么不用一个标准呢?</a><a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><ahref="https://www.ruanyifeng.com/blog/2022/06/endianness-analysis.html">阮一峰-字节序探析：大端与小端的比较</a><a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>考研</category>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统引导简述</title>
    <link href="/2022/07/13/%E8%80%83%E7%A0%94/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC%E7%AE%80%E8%BF%B0/"/>
    <url>/2022/07/13/%E8%80%83%E7%A0%94/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC%E7%AE%80%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p>计算机的启动过程大致分为四个阶段。</p><h2 id="一bios">一、BIOS</h2><p>BIOS程序位于主板中的ROM芯片，计算机通电之后，CPU首先就会读取它。</p><h3 id="post-硬件自检">POST 硬件自检</h3><p>BIOS程序首先会做的就是硬件自检，即检查计算机的硬件是否满足运行的基本要求。如果硬件出现问题，主板会发出蜂鸣声。</p><h3 id="启动顺序-boot-sequence">启动顺序 Boot Sequence</h3><p>完成硬件自检之后，<code>BIOS</code>需要知道下一阶段的程序放在哪里。它需要读取<code>Boot Sequence</code>。</p><blockquote><p>之前有过安装双系统的经验，应该是可以在这个地方设置U盘引导启动。</p></blockquote><h2 id="二mbr-主引导记录">二、MBR 主引导记录</h2><p>BIOS根据读取到的启动顺序，将控制权交给排在第一位的存储设备。</p><p>此时，CPU将读取该存储设备的第一扇区的前512个字节(前512个字节存放MBR，且以<code>0x55 0xAA</code>结尾，这个是一项约定)。</p><p>如果读取到的不是正确的MBR(最后两个字节不合要求)，则控制权会被交给排在启动顺序中第二位的存储设备。</p><h3 id="mbr-结构">MBR 结构</h3><table><thead><tr class="header"><th style="text-align: center;">位置</th><th style="text-align: center;">作用</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1 ~ 446 (446)Bytes</td><td style="text-align: center;">调用操作系统的机器码</td></tr><tr class="even"><td style="text-align: center;">447 ~ 510 (64)Bytes</td><td style="text-align: center;">分区表</td></tr><tr class="odd"><td style="text-align: center;">511 ~ 512 (2)Bytes</td><td style="text-align: center;">签名(0x55, 0xAA)</td></tr></tbody></table><p>其中分区表的作用是将硬盘分成若干个区。</p><h3 id="分区表">分区表</h3><p>硬盘在分区之后，可以安装不同的操作系统，<code>MBR</code>需要知道目标操作系统的引导程序在哪个分区。<code>MBR</code>通过分区的第一个字节来寻找分区，如果第一个字节为<code>0x80</code>，则为目标分区。</p><h2 id="三硬盘启动">三、硬盘启动</h2><p>将控制权交给目标分区后，计算机会读取分区中的第一个扇区中的<code>VBR/PBR</code>。</p><p>它的作用是告诉计算机操作系统在分区中的位置，然后控制权就会被移交给操作系统了。</p><blockquote><p>之前安装双系统的时候，并不是通过自动读取<code>VBR/PBR</code>的方式启动的，而是运行了事先安装的<code>Grub</code>启动管理器，由用户进行选择之后再进行读取，之后再启动的。</p></blockquote><h2 id="四操作系统">四、操作系统</h2><p>控制权交给操作系统之后，操作系统首先会将自己的内核(Kernel)放入内存。</p><p>然后加载初始化进程(Init)。</p><p>之后再进行系统的各个模块的加载，最后进行用户登录，启动完成。</p><h2 id="五参考资料">五、参考资料</h2><p><a href="https://www.ruanyifeng.com/blog/2013/02/booting.html">1.计算机是如何启动的</a></p>]]></content>
    
    
    <categories>
      
      <category>考研</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>计算机原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>归并排序简述</title>
    <link href="/2022/07/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%AE%80%E8%BF%B0/"/>
    <url>/2022/07/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%AE%80%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="简介">简介</h2><p>归并排序主要分为分割操作以及归并操作。</p><p>分割操作指的是将一个数组分成长度相等(或者差<code>1</code>)的两个部分。对于长度为<code>0</code>或者<code>1</code>的数组，可以不用使用分割操作。</p><p>归并操作指的是将两个有序的数组合并成为一个新的有序的数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    <span class="hljs-comment">//归并操作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> right)</span> &#123;<br>        ...<br>    &#125;<br><br>    <span class="hljs-comment">//归并排序(分割操作 + 归并操作)</span><br>    <span class="hljs-comment">//array -&gt; 待排序的数组</span><br>    <span class="hljs-comment">//left, right 表示待排序的数组的区间 [left, right)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        ...<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="归并操作">归并操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    <span class="hljs-comment">//归并操作</span><br>    <span class="hljs-comment">//待合并的两个数组为array的两个区间 [left, mid) [mid, right)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-comment">//获得这两个数组的长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">length1</span> <span class="hljs-operator">=</span> mid - left, length2 = right - mid;<br>        <span class="hljs-keyword">if</span> (length1 &lt;= <span class="hljs-number">0</span> || length2 &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">//获得这两个数组</span><br>        <span class="hljs-type">int</span>[] leftParts = Arrays.copyOfRange(array, left, mid);<br>        <span class="hljs-type">int</span>[] rightParts = Arrays.copyOfRange(array, mid, right);<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftIdx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, rightIdx = <span class="hljs-number">0</span>, index = left;<br>        <span class="hljs-comment">//归并操作</span><br>        <span class="hljs-keyword">while</span> (leftIdx &lt; length1 &amp;&amp; rightIdx &lt; length2) &#123;<br>            <span class="hljs-keyword">if</span> (leftParts[leftIdx] &lt; rightParts[rightIdx]) &#123;<br>                array[index++] = leftParts[leftIdx++];<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                array[index++] = rightParts[rightIdx++];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (leftIdx &lt; length1) &#123;<br>            array[index++] = leftParts[leftIdx++];<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (rightIdx &lt; length2) &#123;<br>            array[index++] = rightParts[rightIdx++];<br>        &#125;<br>    &#125;<br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="归并排序">归并排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>   ...<br><br>    <span class="hljs-comment">//归并排序(分割操作 + 归并操作)</span><br>    <span class="hljs-comment">//array -&gt; 待排序的数组</span><br>    <span class="hljs-comment">//left, right 表示待排序的数组的区间 [left, right)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-comment">//当待排序的数组长度为0或者1时, 停止分割操作</span><br>        <span class="hljs-keyword">if</span> (left + <span class="hljs-number">1</span> &gt;= right) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">//分割操作</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>        mergeSort(array, mid, right);<br>        mergeSort(array, left, mid);<br><br>        <span class="hljs-comment">//合并操作</span><br>        merge(array, left, mid, right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目">相关题目</h2><p><ahref="https://www.acwing.com/problem/content/3718/">最少交换次数-北京师范大学考研机试题</a></p><p>根据归并排序的排序过程，每次碰到逆序对时都会发生交换操作(表现为将数组的右侧部分放到左侧)，只要在发生交换操作时，进行记录即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] reverseArray;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">cin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> cin.nextInt();<br>        <span class="hljs-type">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[total];<br>        Main.reverseArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[total];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; total; ++i) &#123;<br>            array[i] = cin.nextInt();<br>        &#125;<br><br>        <span class="hljs-type">Main</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Main</span>();<br>        m.mergeSort(array, <span class="hljs-number">0</span>, total);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//最终的交换次数就是逆序对数之和</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i : Main.reverseArray) &#123;<br>            sum = sum + i;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; Main.reverseArray.length; ++i) &#123;<br>            System.out.printf(<span class="hljs-string">&quot;%d &quot;</span>, Main.reverseArray[i]);<br>        &#125;<br>        System.out.println();<br>        System.out.printf(<span class="hljs-string">&quot;%d&quot;</span>, sum);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length1</span> <span class="hljs-operator">=</span> mid - left, length2 = right - mid;<br>        <span class="hljs-keyword">if</span> (length1 &lt;= <span class="hljs-number">0</span> || length2 &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span>[] leftParts = Arrays.copyOfRange(array, left, mid);<br>        <span class="hljs-type">int</span>[] rightParts = Arrays.copyOfRange(array, mid, right);<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftIdx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, rightIdx = <span class="hljs-number">0</span>, index = left;<br>        <span class="hljs-keyword">while</span> (leftIdx &lt; length1 &amp;&amp; rightIdx &lt; length2) &#123;<br>            <span class="hljs-keyword">if</span> (leftParts[leftIdx] &lt; rightParts[rightIdx]) &#123;<br>                array[index++] = leftParts[leftIdx++];<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                array[index++] = rightParts[rightIdx];<br>                <span class="hljs-comment">// 发生交换操作 走到这里说明 这个数比leftParts中的所有数都要大 所以当前数数字可以与leftParts中的所有剩余元素都组成逆序对</span><br>                Main.reverseArray[rightParts[rightIdx] - <span class="hljs-number">1</span>] += (length1 - leftIdx);<br>                ++rightIdx;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (leftIdx &lt; length1) &#123;<br>            array[index++] = leftParts[leftIdx++];<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (rightIdx &lt; length2) &#123;<br>            array[index++] = rightParts[rightIdx++];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">if</span> (left + <span class="hljs-number">1</span> &gt;= right) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>        mergeSort(array, mid, right);<br>        mergeSort(array, left, mid);<br>        merge(array, left, mid, right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前缀树简述</title>
    <link href="/2022/07/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%85%B3%E4%BA%8E%E5%89%8D%E7%BC%80%E6%A0%91/"/>
    <url>/2022/07/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%85%B3%E4%BA%8E%E5%89%8D%E7%BC%80%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="简介">简介</h2><p>二叉树每个节点可以有两个子节点，而前缀树每个节点可以有26个子节点。</p><p>每个子节点的索引号表示26个英文字母，子节点内部存放指向下一个节点的引用以及一个<code>isEnd</code>标志位，它用来表示该节点是不是某个字符串的最后一个字符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//前缀树节点</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TireNode</span> &#123;<br>    <span class="hljs-type">boolean</span> isEnd;<br>    TireNode[] childNodes;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TireNode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.isEnd = <span class="hljs-literal">false</span>;<br>        <span class="hljs-built_in">this</span>.childNodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TireNode</span>[<span class="hljs-number">26</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="基本操作">基本操作</h2><p>前缀树的基本操作有插入字符串、查找字符串以及删除字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TireTree</span> &#123;<br>    <span class="hljs-keyword">private</span> TireNode root;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TireTree</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TireNode</span>();<br>    &#125;<br><br>    <span class="hljs-comment">//插入操作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String str)</span> &#123;<br>        ...<br>    &#125;<br><br>    <span class="hljs-comment">//查找操作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">search</span><span class="hljs-params">(String str)</span> &#123;<br>        ...<br>    &#125;<br><br>    <span class="hljs-comment">//删除操作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(String str)</span> &#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="插入操作">插入操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TireTree</span> &#123;<br>    <span class="hljs-keyword">private</span> TireNode root;<br><br>    ...<br>    <span class="hljs-comment">//插入操作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-comment">//如果字符串为空串，则不进行插入操作</span><br>        <span class="hljs-keyword">if</span> (str == <span class="hljs-literal">null</span> || <span class="hljs-string">&quot;&quot;</span>.equals(str)) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-type">char</span>[] strArray = str.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> str.length();<br>        <span class="hljs-type">TireNode</span> <span class="hljs-variable">dummyNode</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.root;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; ++i) &#123;<br>            <span class="hljs-comment">//取得第i个字符的索引</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">currCharIdx</span> <span class="hljs-operator">=</span> strArray[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (dummyNode.childNodes[currCharIdx] == <span class="hljs-literal">null</span>) &#123;<br>                dummyNode.childNodes[currCharIdx] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TireNode</span>();<br>            &#125;<br>            dummyNode = dummyNode.childNodes[currCharIdx];<br>        &#125;<br>        <span class="hljs-comment">//别忘了最后的操作</span><br>        dummyNode.isEnd = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="查找操作">查找操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TireTree</span> &#123;<br>    <span class="hljs-keyword">private</span> TireNode root;<br><br>    ...<br>    <span class="hljs-comment">//查找操作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">search</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-keyword">if</span> (str == <span class="hljs-literal">null</span> || <span class="hljs-string">&quot;&quot;</span>.equals(str)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-type">char</span>[] strArray = str.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> str.length();<br>        <span class="hljs-type">TireNode</span> <span class="hljs-variable">dummyNode</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.root;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">currCharIdx</span> <span class="hljs-operator">=</span> strArray[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (dummyNode.childNodes[currCharIdx] == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            dummyNode = dummyNode.childNodes[currCharIdx];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dummyNode.isEnd;<br>    &#125;<br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="删除操作">删除操作</h3><p>删除操作与查找操作相当类似，只需要将最后的<code>dummyNode.isEnd</code>改成<code>false</code>即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TireTree</span> &#123;<br>    <span class="hljs-keyword">private</span> TireNode root;<br><br>    ...<br>    <span class="hljs-comment">//删除操作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-keyword">if</span> (str == <span class="hljs-literal">null</span> || <span class="hljs-string">&quot;&quot;</span>.equals(str)) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-type">char</span>[] strArray = str.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> str.length();<br>        <span class="hljs-type">TireNode</span> <span class="hljs-variable">dummyNode</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.root;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">currCharIdx</span> <span class="hljs-operator">=</span> strArray[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (dummyNode.childNodes[currCharIdx] == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>            dummyNode = dummyNode.childNodes[currCharIdx];<br>        &#125;<br><br>        dummyNode.isEnd = <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="算法应用">算法应用</h2><h3 id="leetcode-676.-实现一个魔法字典"><ahref="https://leetcode.cn/problems/implement-magic-dictionary/">Leetcode676. 实现一个魔法字典</a></h3><p>在前缀树的搜索基础上进行一些改进即可，下面使用<code>likeSearch()</code>代替<code>search()</code>。</p><p>主要思路是增加一个<code>isModify</code>标志位，表示是否被修改过一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MagicDictionary</span> &#123;<br>    <span class="hljs-keyword">private</span> TireTree tireTree;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MagicDictionary</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.tireTree = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TireTree</span>();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildDict</span><span class="hljs-params">(String[] dictionary)</span> &#123;<br>        <span class="hljs-keyword">for</span> (String str : dictionary) &#123;<br>            <span class="hljs-built_in">this</span>.tireTree.insert(str);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">search</span><span class="hljs-params">(String searchWord)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.tireTree.likeSearch(searchWord);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//前缀树</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TireTree</span> &#123;<br>    <span class="hljs-keyword">private</span> TireNode root;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TireTree</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TireNode</span>();<br>    &#125;<br><br>    <span class="hljs-comment">//普通插入方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-keyword">if</span> (str == <span class="hljs-literal">null</span> || <span class="hljs-string">&quot;&quot;</span>.equals(str)) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">char</span>[] strArray = str.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> str.length();<br>        <span class="hljs-type">TireNode</span> <span class="hljs-variable">dummyNode</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">currCharIdx</span> <span class="hljs-operator">=</span> strArray[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (dummyNode.childNodes[currCharIdx] == <span class="hljs-literal">null</span>) &#123;<br>                dummyNode.childNodes[currCharIdx] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TireNode</span>();<br>            &#125;<br>            dummyNode = dummyNode.childNodes[currCharIdx];<br>        &#125;<br>        dummyNode.isEnd = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//普通搜索方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">search</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-keyword">if</span> (str == <span class="hljs-literal">null</span> || <span class="hljs-string">&quot;&quot;</span>.equals(str)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">char</span>[] strArray = str.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> str.length();<br>        <span class="hljs-type">TireNode</span> <span class="hljs-variable">dummyNode</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">currCharIdx</span> <span class="hljs-operator">=</span> strArray[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (dummyNode.childNodes[currCharIdx] == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            dummyNode = dummyNode.childNodes[currCharIdx];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummyNode.isEnd;<br>    &#125;<br><br>    <span class="hljs-comment">//符合题目要求的搜索方法的递归实现 增加一个isModify标志位即可</span><br>    <span class="hljs-comment">//returnVal -&gt; 搜索结果</span><br>    <span class="hljs-comment">//strArray -&gt; 待搜索的字符串</span><br>    <span class="hljs-comment">//isModify -&gt; 是否已经进行过修改操作</span><br>    <span class="hljs-comment">//currentNode -&gt; 当前所在的节点位置</span><br>    <span class="hljs-comment">//currentIndex -&gt; 当前正在处理strArray的第几个字符</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">likeSearch</span><span class="hljs-params">(<span class="hljs-type">char</span>[] strArray, <span class="hljs-type">boolean</span> isModify, TireNode currentNode, <span class="hljs-type">int</span> currentIndex)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> strArray.length;<br>        <span class="hljs-comment">//如果匹配到最后一个字符 则返回搜索结果(根据题目要求 此时必须已经被修改过)</span><br>        <span class="hljs-keyword">if</span> (currentIndex == length) <span class="hljs-keyword">return</span> isModify &amp;&amp; currentNode.isEnd;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">currCharIdx</span> <span class="hljs-operator">=</span> strArray[currentIndex] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (currentNode.childNodes[i] == <span class="hljs-literal">null</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (i == currCharIdx) &#123;<br>                result = result | likeSearch(strArray, isModify, currentNode.childNodes[i], currentIndex + <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (isModify) <span class="hljs-keyword">continue</span>;<br>            result = result | likeSearch(strArray, <span class="hljs-literal">true</span>, currentNode.childNodes[i], currentIndex + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">//进行简单的封装</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">likeSearch</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-keyword">return</span> likeSearch(str.toCharArray(), <span class="hljs-literal">false</span>, <span class="hljs-built_in">this</span>.root, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//前缀树节点</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TireNode</span> &#123;<br>    <span class="hljs-type">boolean</span> isEnd;<br>    TireNode[] childNodes;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TireNode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.isEnd = <span class="hljs-literal">false</span>;<br>        <span class="hljs-built_in">this</span>.childNodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TireNode</span>[<span class="hljs-number">26</span>];<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MagicDictionary object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MagicDictionary obj = new MagicDictionary();</span><br><span class="hljs-comment"> * obj.buildDict(dictionary);</span><br><span class="hljs-comment"> * boolean param_2 = obj.search(searchWord);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="实际应用">实际应用</h2><p>前缀树通常用在纯算法领域，在实际工程中，一般不会只有<code>26</code>个小写字母的字符匹配，前缀树也不会比直接使用<code>Hash</code>更有优势。</p><p>另外在联想输入、模糊匹配等场景用到的技术应该是<code>倒排索引</code>(例如<code>ElasticSearch</code>)。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前缀树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第81场双周赛 Leetcode</title>
    <link href="/2022/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%AF%94%E8%B5%9B/%E7%AC%AC81%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B-Leetcode/"/>
    <url>/2022/07/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%AF%94%E8%B5%9B/%E7%AC%AC81%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B-Leetcode/</url>
    
    <content type="html"><![CDATA[<h2 id="统计星号">1. <ahref="https://leetcode.cn/problems/count-asterisks/">统计星号</a></h2><blockquote><p>使用一个<code>isInner</code>变量来判断当前是否在一对<code>'|'</code>之间。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countAsterisks</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">char</span>[] sArray = s.toCharArray();<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isInner</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : sArray) &#123;<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;|&#x27;</span>) &#123;<br>                isInner = !isInner;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;*&#x27;</span> &amp;&amp; !isInner) &#123;<br>                ++ret;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="统计无向图中无法互相到达点对数">2. <ahref="https://leetcode.cn/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/">统计无向图中无法互相到达点对数</a></h2><blockquote><p>使用并查集，将相互之间可以到达的点划分到同一个集合中。之后统计每个子集中点的数目就可以算出点的对数。</p></blockquote><p>假设当前的某一个集合中有<code>count</code>个节点，记<code>n</code>为所有点的数目，则当前集合能与集合外的点形成的点的数目<code>res</code>为</p><p><span class="math display">\[    res = count \times (n - count)\]</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">countPairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] edges)</span> &#123;<br>        <span class="hljs-comment">//并查集初始化</span><br>        <span class="hljs-type">int</span>[] parents = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            parents[i] = i;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] edge : edges) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> edge[<span class="hljs-number">0</span>], dist = edge[<span class="hljs-number">1</span>];<br>            merge(parents, start, dist);<br>        &#125;<br><br>        Map&lt;Integer, Integer&gt; countMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> find(parents, i);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> countMap.getOrDefault(parent, <span class="hljs-number">0</span>);<br>            countMap.put(parent, count + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0L</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> entry : countMap.entrySet()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> entry.getValue();<br>            res = res + (count * <span class="hljs-number">1L</span> * (n - count));<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res / <span class="hljs-number">2</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//寻找 (路径压缩)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span>[] parents, <span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-keyword">if</span> (parents[i] == i) <span class="hljs-keyword">return</span> i;<br>        parents[i] = find(parents, parents[i]);<br>        <span class="hljs-keyword">return</span> parents[i];<br>    &#125;<br><br>    <span class="hljs-comment">//合并 将i合并至j</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] parents, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        parents[find(parents, i)] = find(parents, j);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="操作后的最大异或和">3. <ahref="https://leetcode.cn/problems/maximum-xor-after-operations/">操作后的最大异或和</a></h2><p>题目中的选择任意一个整数<code>x</code>，然后做<code>nums[i] AND (nums[i] XOR x)</code>，代表着可以选择将<code>nums[i]</code>的任意一位<code>1</code>改成<code>0</code>，但是不能将<code>0</code>改成<code>1</code>，这是<code>AND</code>操作的特点。</p><p>想要得到最大的逐位异或和就是代表异或的结果需要有尽可能多的位数为<code>1</code>。</p><p>因为只能将<code>nums[i]</code>的任意一位<code>1</code>改成<code>0</code>，所以要想得到最大异或和，应当尽可能的保存最多的<code>1</code>；或者说，将<code>nums</code>出现的所有<code>1</code>全部保留<code>1</code>次。符合或运算的特点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumXOR</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            res = res | num;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="不同骰子序列的数目">4. <ahref="https://leetcode.cn/problems/number-of-distinct-roll-sequences/">不同骰子序列的数目</a></h2><p>分析题目，观察到一个序列中第<code>x</code>位的取值，与它的前两位有关，所以这里的状态数组可以使用两个维度来表示骰子的取值。</p><p><code>dp[i][j][k] -&gt; 投掷第i次骰子, 最后一次投掷出k, 倒数第二次投掷出j时, 合法序列的数目</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">distinctSequences</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[][][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][<span class="hljs-number">7</span>][<span class="hljs-number">7</span>];<br>        <span class="hljs-comment">//对n == 1的情况的特判</span><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">6</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//初始化状态数组/状态数组的边界处理 n == 2 的情况</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">7</span>; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">7</span>; ++j) &#123;<br>                <span class="hljs-comment">//如果第一个数与第二个数不相等, 且最大公约数为1</span><br>                <span class="hljs-keyword">if</span> (i != j &amp;&amp; gcd(i, j) == <span class="hljs-number">1</span>) &#123;<br>                    dp[<span class="hljs-number">2</span>][i][j] = <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//填写状态数组/状态转移</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>; i &lt;= n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">7</span>; ++j) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; k &lt; <span class="hljs-number">7</span>; ++k) &#123;<br>                    <span class="hljs-comment">//最后一次的点数与倒数第二次的点数符合要求</span><br>                    <span class="hljs-keyword">if</span> (j != k &amp;&amp; gcd(j, k) == <span class="hljs-number">1</span>) &#123;<br>                        <span class="hljs-comment">//状态转移 枚举当前点k的前第2个点 s j k</span><br>                        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; s &lt; <span class="hljs-number">7</span>; ++s) &#123;<br>                            <span class="hljs-keyword">if</span> (k != s &amp;&amp; s != j &amp;&amp; gcd(j, s) == <span class="hljs-number">1</span>)<br>                                dp[i][j][k] = (dp[i][j][k] + dp[i - <span class="hljs-number">1</span>][s][j]) % MOD;                        <br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//统计结果</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">7</span>; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">7</span>; ++j) &#123;<br>                result = (result + dp[n][i][j]) % MOD;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">//辗转相除法求最大公约数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> b &gt; <span class="hljs-number">0</span> ? gcd(b, a % b) : a;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>比赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode 双周赛</tag>
      
      <tag>模拟</tag>
      
      <tag>并查集</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo图片问题 处理方式1</title>
    <link href="/2022/06/26/Hexo%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98-%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F1/"/>
    <url>/2022/06/26/Hexo%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98-%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F1/</url>
    
    <content type="html"><![CDATA[<h2 id="hexo图片问题-处理方式1">Hexo图片问题 处理方式1</h2><p>初次搭建博客，暂时使用<code>GitHub</code>来做图床，计划后续迁移到七牛云。</p><h2 id="下载picgo">下载<ahref="https://github.com/Molunerfinn/PicGo/releases">PicGo</a></h2><p>下载PicGo用来进行图片上传</p><h2 id="在github中新建一个仓库">在<code>GitHub</code>中新建一个仓库</h2><p>在<code>GitHub</code>中新建一个仓库，用来存放静态资源。仓库的名字可以任意。</p><h2 id="配置picgo">配置PicGo</h2><figure><imgsrc="https://cdn.jsdelivr.net/gh/Chen-SC4/HexoImages/20220626140227.png"alt="Pic配置图片" /><figcaption aria-hidden="true">Pic配置图片</figcaption></figure><ul><li>设定仓库名 填写<code>用户名/仓库名</code></li><li>分支名 默认填写为<code>main</code></li><li>Token用于验证个人身份<ul><li>点击<code>GitHub</code>右上角个人头像 <code>settings</code></li><li>点击左侧菜单最底部的<code>Developer Settings</code><ul><li>点击左侧菜单中的 <code>Personal access tokens</code></li><li>点击 <code>Generate new token</code></li><li><code>Note</code> 中填写<code>token</code>的使用目的</li><li><code>Expiration</code>表示<code>token</code>的有效时间可以选择永久</li><li><code>Select Scope</code>选择第一个<code>repo</code>即可</li></ul></li></ul></li><li>设定自定义域名 该项为可选项<ul><li>如果不填 从国内访问博客 图片加载可能会很慢</li><li>可以填写一个免费的CDN加速<code>https://cdn.jsdelivr.net/gh/GitHub用户名/仓库名</code></li><li><code>jsdelivr</code>有下线的风险，推荐后续将图片资源转移到自己的服务器上</li></ul></li></ul><h2 id="点击确定-配置完成">点击确定 配置完成</h2><p>之后只要截取图片使用<code>PicGo</code>上传，然后选择链接格式，再在<code>相册</code>中找到对应的图片，点击复制链接即可。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/06/25/hello-world/"/>
    <url>/2022/06/25/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <ahref="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <ahref="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
