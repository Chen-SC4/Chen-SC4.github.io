<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>大端序与小端序简述</title>
    <link href="/2022/07/14/%E5%A4%A7%E7%AB%AF%E5%BA%8F%E4%B8%8E%E5%B0%8F%E7%AB%AF%E5%BA%8F%E7%AE%80%E8%BF%B0/"/>
    <url>/2022/07/14/%E5%A4%A7%E7%AB%AF%E5%BA%8F%E4%B8%8E%E5%B0%8F%E7%AB%AF%E5%BA%8F%E7%AE%80%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="字节序">字节序</h2><blockquote><p>字节顺序，又称端序或尾序（英语：Endianness），在计算机科学领域中，指电脑内存中或在数字通信链路中，组成多字节的字的字节的排列顺序。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[字节顺序-Wikipedia](https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F)">[1]</span></a></sup></p></blockquote><p>我们常说的大端序与小端序就是两种排列顺序。</p><h2 id="大端序与小端序">大端序与小端序</h2><p>大端序就是大头在前，将高位的字节放在低位的地址上，这样人在阅读时就会比较方便，因为从左到右阅读对应着地址从低到高，符合人们的阅读习惯。</p><p>小端序与大端序相反，将低位的字节放在低位的地址上，这样不利于人的阅读，但是利于计算机的运算操作，因为在四则运算中，需要从低位开始计算然后判断进位，之后算到高位。</p><p>下面的例子中，分别使用大端序存储和小端序存储来存储<code>0x1234 5678</code>。</p><center><table><thead><tr class="header"><th style="text-align: center;">0</th><th style="text-align: center;">1</th><th style="text-align: center;">2</th><th style="text-align: center;">3</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">0x12</td><td style="text-align: center;">0x34</td><td style="text-align: center;">0x56</td><td style="text-align: center;">0x78</td></tr></tbody></table><p><font face="楷体">大端序存储</font></p></center><center><table><thead><tr class="header"><th style="text-align: center;">0</th><th style="text-align: center;">1</th><th style="text-align: center;">2</th><th style="text-align: center;">3</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">0x78</td><td style="text-align: center;">0x56</td><td style="text-align: center;">0x34</td><td style="text-align: center;">0x12</td></tr></tbody></table><p><font face="楷体">小端序存储</font></p></center><p>例如检查奇偶性，在大端序中，计算机需要读到最后一位才知道时奇数还是偶数，然而在小端序中，计算机只用读第一位就知道了。</p><p>不过小端序并不总是对计算机友好，例如在判断正负号时，大端序就能在第一位判断出来，而小端序则需要读取到最后一位。</p><p>类似的运算还有很多，综合的看，小端序的存储顺序有利于四则运算这种逐位的运算，而大端存储方式有利于只针对于高位的计算，例如判断正负号等。</p><h2 id="参考资料">参考资料</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><ahref="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F">字节顺序-Wikipedia</a><a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><ahref="https://www.zhihu.com/question/25311159">知乎-大小端字节序存在的意义，为什么不用一个标准呢?</a><a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><ahref="https://www.ruanyifeng.com/blog/2022/06/endianness-analysis.html">阮一峰-字节序探析：大端与小端的比较</a><a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>考研</category>
      
      <category>计算机组成原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统引导简述</title>
    <link href="/2022/07/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC%E7%AE%80%E8%BF%B0/"/>
    <url>/2022/07/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC%E7%AE%80%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p>计算机的启动过程大致分为四个阶段。</p><h2 id="一bios">一、BIOS</h2><p>BIOS程序位于主板中的ROM芯片，计算机通电之后，CPU首先就会读取它。</p><h3 id="post-硬件自检">POST 硬件自检</h3><p>BIOS程序首先会做的就是硬件自检，即检查计算机的硬件是否满足运行的基本要求。如果硬件出现问题，主板会发出蜂鸣声。</p><h3 id="启动顺序-boot-sequence">启动顺序 Boot Sequence</h3><p>完成硬件自检之后，<code>BIOS</code>需要知道下一阶段的程序放在哪里。它需要读取<code>Boot Sequence</code>。</p><blockquote><p>之前有过安装双系统的经验，应该是可以在这个地方设置U盘引导启动。</p></blockquote><h2 id="二mbr-主引导记录">二、MBR 主引导记录</h2><p>BIOS根据读取到的启动顺序，将控制权交给排在第一位的存储设备。</p><p>此时，CPU将读取该存储设备的第一扇区的前512个字节(前512个字节存放MBR，且以<code>0x55 0xAA</code>结尾，这个是一项约定)。</p><p>如果读取到的不是正确的MBR(最后两个字节不合要求)，则控制权会被交给排在启动顺序中第二位的存储设备。</p><h3 id="mbr-结构">MBR 结构</h3><table><thead><tr class="header"><th style="text-align: center;">位置</th><th style="text-align: center;">作用</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1 ~ 446 (446)Bytes</td><td style="text-align: center;">调用操作系统的机器码</td></tr><tr class="even"><td style="text-align: center;">447 ~ 510 (64)Bytes</td><td style="text-align: center;">分区表</td></tr><tr class="odd"><td style="text-align: center;">511 ~ 512 (2)Bytes</td><td style="text-align: center;">签名(0x55, 0xAA)</td></tr></tbody></table><p>其中分区表的作用是将硬盘分成若干个区。</p><h3 id="分区表">分区表</h3><p>硬盘在分区之后，可以安装不同的操作系统，<code>MBR</code>需要知道目标操作系统的引导程序在哪个分区。<code>MBR</code>通过分区的第一个字节来寻找分区，如果第一个字节为<code>0x80</code>，则为目标分区。</p><h2 id="三硬盘启动">三、硬盘启动</h2><p>将控制权交给目标分区后，计算机会读取分区中的第一个扇区中的<code>VBR/PBR</code>。</p><p>它的作用是告诉计算机操作系统在分区中的位置，然后控制权就会被移交给操作系统了。</p><blockquote><p>之前安装双系统的时候，并不是通过自动读取<code>VBR/PBR</code>的方式启动的，而是运行了事先安装的<code>Grub</code>启动管理器，由用户进行选择之后再进行读取，之后再启动的。</p></blockquote><h2 id="四操作系统">四、操作系统</h2><p>控制权交给操作系统之后，操作系统首先会将自己的内核(Kernel)放入内存。</p><p>然后加载初始化进程(Init)。</p><p>之后再进行系统的各个模块的加载，最后进行用户登录，启动完成。</p><h2 id="五参考资料">五、参考资料</h2><p><a href="https://www.ruanyifeng.com/blog/2013/02/booting.html">1.计算机是如何启动的</a></p>]]></content>
    
    
    <categories>
      
      <category>考研</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统 计算机原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>归并排序简述</title>
    <link href="/2022/07/11/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%AE%80%E8%BF%B0/"/>
    <url>/2022/07/11/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%AE%80%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="简介">简介</h2><p>归并排序主要分为分割操作以及归并操作。</p><p>分割操作指的是将一个数组分成长度相等(或者差<code>1</code>)的两个部分。对于长度为<code>0</code>或者<code>1</code>的数组，可以不用使用分割操作。</p><p>归并操作指的是将两个有序的数组合并成为一个新的有序的数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    <span class="hljs-comment">//归并操作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> right)</span> &#123;<br>        ...<br>    &#125;<br><br>    <span class="hljs-comment">//归并排序(分割操作 + 归并操作)</span><br>    <span class="hljs-comment">//array -&gt; 待排序的数组</span><br>    <span class="hljs-comment">//left, right 表示待排序的数组的区间 [left, right)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        ...<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="归并操作">归并操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    <span class="hljs-comment">//归并操作</span><br>    <span class="hljs-comment">//待合并的两个数组为array的两个区间 [left, mid) [mid, right)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-comment">//获得这两个数组的长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">length1</span> <span class="hljs-operator">=</span> mid - left, length2 = right - mid;<br>        <span class="hljs-keyword">if</span> (length1 &lt;= <span class="hljs-number">0</span> || length2 &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">//获得这两个数组</span><br>        <span class="hljs-type">int</span>[] leftParts = Arrays.copyOfRange(array, left, mid);<br>        <span class="hljs-type">int</span>[] rightParts = Arrays.copyOfRange(array, mid, right);<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftIdx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, rightIdx = <span class="hljs-number">0</span>, index = left;<br>        <span class="hljs-comment">//归并操作</span><br>        <span class="hljs-keyword">while</span> (leftIdx &lt; length1 &amp;&amp; rightIdx &lt; length2) &#123;<br>            <span class="hljs-keyword">if</span> (leftParts[leftIdx] &lt; rightParts[rightIdx]) &#123;<br>                array[index++] = leftParts[leftIdx++];<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                array[index++] = rightParts[rightIdx++];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (leftIdx &lt; length1) &#123;<br>            array[index++] = leftParts[leftIdx++];<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (rightIdx &lt; length2) &#123;<br>            array[index++] = rightParts[rightIdx++];<br>        &#125;<br>    &#125;<br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="归并排序">归并排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>   ...<br><br>    <span class="hljs-comment">//归并排序(分割操作 + 归并操作)</span><br>    <span class="hljs-comment">//array -&gt; 待排序的数组</span><br>    <span class="hljs-comment">//left, right 表示待排序的数组的区间 [left, right)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-comment">//当待排序的数组长度为0或者1时, 停止分割操作</span><br>        <span class="hljs-keyword">if</span> (left + <span class="hljs-number">1</span> &gt;= right) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">//分割操作</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>        mergeSort(array, mid, right);<br>        mergeSort(array, left, mid);<br><br>        <span class="hljs-comment">//合并操作</span><br>        merge(array, left, mid, right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目">相关题目</h2><p><ahref="https://www.acwing.com/problem/content/3718/">最少交换次数-北京师范大学考研机试题</a></p><p>根据归并排序的排序过程，每次碰到逆序对时都会发生交换操作(表现为将数组的右侧部分放到左侧)，只要在发生交换操作时，进行记录即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] reverseArray;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">cin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> cin.nextInt();<br>        <span class="hljs-type">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[total];<br>        Main.reverseArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[total];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; total; ++i) &#123;<br>            array[i] = cin.nextInt();<br>        &#125;<br><br>        <span class="hljs-type">Main</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Main</span>();<br>        m.mergeSort(array, <span class="hljs-number">0</span>, total);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//最终的交换次数就是逆序对数之和</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i : Main.reverseArray) &#123;<br>            sum = sum + i;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; Main.reverseArray.length; ++i) &#123;<br>            System.out.printf(<span class="hljs-string">&quot;%d &quot;</span>, Main.reverseArray[i]);<br>        &#125;<br>        System.out.println();<br>        System.out.printf(<span class="hljs-string">&quot;%d&quot;</span>, sum);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length1</span> <span class="hljs-operator">=</span> mid - left, length2 = right - mid;<br>        <span class="hljs-keyword">if</span> (length1 &lt;= <span class="hljs-number">0</span> || length2 &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span>[] leftParts = Arrays.copyOfRange(array, left, mid);<br>        <span class="hljs-type">int</span>[] rightParts = Arrays.copyOfRange(array, mid, right);<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftIdx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, rightIdx = <span class="hljs-number">0</span>, index = left;<br>        <span class="hljs-keyword">while</span> (leftIdx &lt; length1 &amp;&amp; rightIdx &lt; length2) &#123;<br>            <span class="hljs-keyword">if</span> (leftParts[leftIdx] &lt; rightParts[rightIdx]) &#123;<br>                array[index++] = leftParts[leftIdx++];<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                array[index++] = rightParts[rightIdx];<br>                <span class="hljs-comment">// 发生交换操作 走到这里说明 这个数比leftParts中的所有数都要大 所以当前数数字可以与leftParts中的所有剩余元素都组成逆序对</span><br>                Main.reverseArray[rightParts[rightIdx] - <span class="hljs-number">1</span>] += (length1 - leftIdx);<br>                ++rightIdx;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (leftIdx &lt; length1) &#123;<br>            array[index++] = leftParts[leftIdx++];<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (rightIdx &lt; length2) &#123;<br>            array[index++] = rightParts[rightIdx++];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>        <span class="hljs-keyword">if</span> (left + <span class="hljs-number">1</span> &gt;= right) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>        mergeSort(array, mid, right);<br>        mergeSort(array, left, mid);<br>        merge(array, left, mid, right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前缀树简述</title>
    <link href="/2022/07/11/%E5%85%B3%E4%BA%8E%E5%89%8D%E7%BC%80%E6%A0%91/"/>
    <url>/2022/07/11/%E5%85%B3%E4%BA%8E%E5%89%8D%E7%BC%80%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="简介">简介</h2><p>二叉树每个节点可以有两个子节点，而前缀树每个节点可以有26个子节点。</p><p>每个子节点的索引号表示26个英文字母，子节点内部存放指向下一个节点的引用以及一个<code>isEnd</code>标志位，它用来表示该节点是不是某个字符串的最后一个字符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//前缀树节点</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TireNode</span> &#123;<br>    <span class="hljs-type">boolean</span> isEnd;<br>    TireNode[] childNodes;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TireNode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.isEnd = <span class="hljs-literal">false</span>;<br>        <span class="hljs-built_in">this</span>.childNodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TireNode</span>[<span class="hljs-number">26</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="基本操作">基本操作</h2><p>前缀树的基本操作有插入字符串、查找字符串以及删除字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TireTree</span> &#123;<br>    <span class="hljs-keyword">private</span> TireNode root;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TireTree</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TireNode</span>();<br>    &#125;<br><br>    <span class="hljs-comment">//插入操作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String str)</span> &#123;<br>        ...<br>    &#125;<br><br>    <span class="hljs-comment">//查找操作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">search</span><span class="hljs-params">(String str)</span> &#123;<br>        ...<br>    &#125;<br><br>    <span class="hljs-comment">//删除操作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(String str)</span> &#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="插入操作">插入操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TireTree</span> &#123;<br>    <span class="hljs-keyword">private</span> TireNode root;<br><br>    ...<br>    <span class="hljs-comment">//插入操作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-comment">//如果字符串为空串，则不进行插入操作</span><br>        <span class="hljs-keyword">if</span> (str == <span class="hljs-literal">null</span> || <span class="hljs-string">&quot;&quot;</span>.equals(str)) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-type">char</span>[] strArray = str.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> str.length();<br>        <span class="hljs-type">TireNode</span> <span class="hljs-variable">dummyNode</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.root;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; ++i) &#123;<br>            <span class="hljs-comment">//取得第i个字符的索引</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">currCharIdx</span> <span class="hljs-operator">=</span> strArray[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (dummyNode.childNodes[currCharIdx] == <span class="hljs-literal">null</span>) &#123;<br>                dummyNode.childNodes[currCharIdx] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TireNode</span>();<br>            &#125;<br>            dummyNode = dummyNode.childNodes[currCharIdx];<br>        &#125;<br>        <span class="hljs-comment">//别忘了最后的操作</span><br>        dummyNode.isEnd = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="查找操作">查找操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TireTree</span> &#123;<br>    <span class="hljs-keyword">private</span> TireNode root;<br><br>    ...<br>    <span class="hljs-comment">//查找操作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">search</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-keyword">if</span> (str == <span class="hljs-literal">null</span> || <span class="hljs-string">&quot;&quot;</span>.equals(str)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-type">char</span>[] strArray = str.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> str.length();<br>        <span class="hljs-type">TireNode</span> <span class="hljs-variable">dummyNode</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.root;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">currCharIdx</span> <span class="hljs-operator">=</span> strArray[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (dummyNode.childNodes[currCharIdx] == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            dummyNode = dummyNode.childNodes[currCharIdx];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dummyNode.isEnd;<br>    &#125;<br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="删除操作">删除操作</h3><p>删除操作与查找操作相当类似，只需要将最后的<code>dummyNode.isEnd</code>改成<code>false</code>即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TireTree</span> &#123;<br>    <span class="hljs-keyword">private</span> TireNode root;<br><br>    ...<br>    <span class="hljs-comment">//删除操作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-keyword">if</span> (str == <span class="hljs-literal">null</span> || <span class="hljs-string">&quot;&quot;</span>.equals(str)) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-type">char</span>[] strArray = str.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> str.length();<br>        <span class="hljs-type">TireNode</span> <span class="hljs-variable">dummyNode</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.root;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">currCharIdx</span> <span class="hljs-operator">=</span> strArray[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (dummyNode.childNodes[currCharIdx] == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>            dummyNode = dummyNode.childNodes[currCharIdx];<br>        &#125;<br><br>        dummyNode.isEnd = <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="算法应用">算法应用</h2><h3 id="leetcode-676.-实现一个魔法字典"><ahref="https://leetcode.cn/problems/implement-magic-dictionary/">Leetcode676. 实现一个魔法字典</a></h3><p>在前缀树的搜索基础上进行一些改进即可，下面使用<code>likeSearch()</code>代替<code>search()</code>。</p><p>主要思路是增加一个<code>isModify</code>标志位，表示是否被修改过一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MagicDictionary</span> &#123;<br>    <span class="hljs-keyword">private</span> TireTree tireTree;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MagicDictionary</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.tireTree = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TireTree</span>();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildDict</span><span class="hljs-params">(String[] dictionary)</span> &#123;<br>        <span class="hljs-keyword">for</span> (String str : dictionary) &#123;<br>            <span class="hljs-built_in">this</span>.tireTree.insert(str);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">search</span><span class="hljs-params">(String searchWord)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.tireTree.likeSearch(searchWord);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//前缀树</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TireTree</span> &#123;<br>    <span class="hljs-keyword">private</span> TireNode root;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TireTree</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TireNode</span>();<br>    &#125;<br><br>    <span class="hljs-comment">//普通插入方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-keyword">if</span> (str == <span class="hljs-literal">null</span> || <span class="hljs-string">&quot;&quot;</span>.equals(str)) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">char</span>[] strArray = str.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> str.length();<br>        <span class="hljs-type">TireNode</span> <span class="hljs-variable">dummyNode</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">currCharIdx</span> <span class="hljs-operator">=</span> strArray[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (dummyNode.childNodes[currCharIdx] == <span class="hljs-literal">null</span>) &#123;<br>                dummyNode.childNodes[currCharIdx] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TireNode</span>();<br>            &#125;<br>            dummyNode = dummyNode.childNodes[currCharIdx];<br>        &#125;<br>        dummyNode.isEnd = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//普通搜索方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">search</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-keyword">if</span> (str == <span class="hljs-literal">null</span> || <span class="hljs-string">&quot;&quot;</span>.equals(str)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">char</span>[] strArray = str.toCharArray();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> str.length();<br>        <span class="hljs-type">TireNode</span> <span class="hljs-variable">dummyNode</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">currCharIdx</span> <span class="hljs-operator">=</span> strArray[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (dummyNode.childNodes[currCharIdx] == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            dummyNode = dummyNode.childNodes[currCharIdx];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummyNode.isEnd;<br>    &#125;<br><br>    <span class="hljs-comment">//符合题目要求的搜索方法的递归实现 增加一个isModify标志位即可</span><br>    <span class="hljs-comment">//returnVal -&gt; 搜索结果</span><br>    <span class="hljs-comment">//strArray -&gt; 待搜索的字符串</span><br>    <span class="hljs-comment">//isModify -&gt; 是否已经进行过修改操作</span><br>    <span class="hljs-comment">//currentNode -&gt; 当前所在的节点位置</span><br>    <span class="hljs-comment">//currentIndex -&gt; 当前正在处理strArray的第几个字符</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">likeSearch</span><span class="hljs-params">(<span class="hljs-type">char</span>[] strArray, <span class="hljs-type">boolean</span> isModify, TireNode currentNode, <span class="hljs-type">int</span> currentIndex)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> strArray.length;<br>        <span class="hljs-comment">//如果匹配到最后一个字符 则返回搜索结果(根据题目要求 此时必须已经被修改过)</span><br>        <span class="hljs-keyword">if</span> (currentIndex == length) <span class="hljs-keyword">return</span> isModify &amp;&amp; currentNode.isEnd;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">currCharIdx</span> <span class="hljs-operator">=</span> strArray[currentIndex] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (currentNode.childNodes[i] == <span class="hljs-literal">null</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (i == currCharIdx) &#123;<br>                result = result | likeSearch(strArray, isModify, currentNode.childNodes[i], currentIndex + <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (isModify) <span class="hljs-keyword">continue</span>;<br>            result = result | likeSearch(strArray, <span class="hljs-literal">true</span>, currentNode.childNodes[i], currentIndex + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">//进行简单的封装</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">likeSearch</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-keyword">return</span> likeSearch(str.toCharArray(), <span class="hljs-literal">false</span>, <span class="hljs-built_in">this</span>.root, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//前缀树节点</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TireNode</span> &#123;<br>    <span class="hljs-type">boolean</span> isEnd;<br>    TireNode[] childNodes;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TireNode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.isEnd = <span class="hljs-literal">false</span>;<br>        <span class="hljs-built_in">this</span>.childNodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TireNode</span>[<span class="hljs-number">26</span>];<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MagicDictionary object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MagicDictionary obj = new MagicDictionary();</span><br><span class="hljs-comment"> * obj.buildDict(dictionary);</span><br><span class="hljs-comment"> * boolean param_2 = obj.search(searchWord);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="实际应用">实际应用</h2><p>前缀树通常用在纯算法领域，在实际工程中，一般不会只有<code>26</code>个小写字母的字符匹配，前缀树也不会比直接使用<code>Hash</code>更有优势。</p><p>另外在联想输入、模糊匹配等场景用到的技术应该是<code>倒排索引</code>(例如<code>ElasticSearch</code>)。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前缀树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第81场双周赛 Leetcode</title>
    <link href="/2022/07/09/%E7%AC%AC81%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B-Leetcode/"/>
    <url>/2022/07/09/%E7%AC%AC81%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B-Leetcode/</url>
    
    <content type="html"><![CDATA[<h2 id="统计星号">1. <ahref="https://leetcode.cn/problems/count-asterisks/">统计星号</a></h2><blockquote><p>使用一个<code>isInner</code>变量来判断当前是否在一对<code>'|'</code>之间。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countAsterisks</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">char</span>[] sArray = s.toCharArray();<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isInner</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : sArray) &#123;<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;|&#x27;</span>) &#123;<br>                isInner = !isInner;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;*&#x27;</span> &amp;&amp; !isInner) &#123;<br>                ++ret;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="统计无向图中无法互相到达点对数">2. <ahref="https://leetcode.cn/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/">统计无向图中无法互相到达点对数</a></h2><blockquote><p>使用并查集，将相互之间可以到达的点划分到同一个集合中。之后统计每个子集中点的数目就可以算出点的对数。</p></blockquote><p>假设当前的某一个集合中有<code>count</code>个节点，记<code>n</code>为所有点的数目，则当前集合能与集合外的点形成的点的数目<code>res</code>为</p><p><span class="math display">\[    res = count \times (n - count)\]</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">countPairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] edges)</span> &#123;<br>        <span class="hljs-comment">//并查集初始化</span><br>        <span class="hljs-type">int</span>[] parents = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            parents[i] = i;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] edge : edges) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> edge[<span class="hljs-number">0</span>], dist = edge[<span class="hljs-number">1</span>];<br>            merge(parents, start, dist);<br>        &#125;<br><br>        Map&lt;Integer, Integer&gt; countMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> find(parents, i);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> countMap.getOrDefault(parent, <span class="hljs-number">0</span>);<br>            countMap.put(parent, count + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0L</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> entry : countMap.entrySet()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> entry.getValue();<br>            res = res + (count * <span class="hljs-number">1L</span> * (n - count));<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res / <span class="hljs-number">2</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//寻找 (路径压缩)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span>[] parents, <span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-keyword">if</span> (parents[i] == i) <span class="hljs-keyword">return</span> i;<br>        parents[i] = find(parents, parents[i]);<br>        <span class="hljs-keyword">return</span> parents[i];<br>    &#125;<br><br>    <span class="hljs-comment">//合并 将i合并至j</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] parents, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        parents[find(parents, i)] = find(parents, j);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="操作后的最大异或和">3. <ahref="https://leetcode.cn/problems/maximum-xor-after-operations/">操作后的最大异或和</a></h2><p>题目中的选择任意一个整数<code>x</code>，然后做<code>nums[i] AND (nums[i] XOR x)</code>，代表着可以选择将<code>nums[i]</code>的任意一位<code>1</code>改成<code>0</code>，但是不能将<code>0</code>改成<code>1</code>，这是<code>AND</code>操作的特点。</p><p>想要得到最大的逐位异或和就是代表异或的结果需要有尽可能多的位数为<code>1</code>。</p><p>因为只能将<code>nums[i]</code>的任意一位<code>1</code>改成<code>0</code>，所以要想得到最大异或和，应当尽可能的保存最多的<code>1</code>；或者说，将<code>nums</code>出现的所有<code>1</code>全部保留<code>1</code>次。符合或运算的特点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumXOR</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>            res = res | num;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="不同骰子序列的数目">4. <ahref="https://leetcode.cn/problems/number-of-distinct-roll-sequences/">不同骰子序列的数目</a></h2><p>分析题目，观察到一个序列中第<code>x</code>位的取值，与它的前两位有关，所以这里的状态数组可以使用两个维度来表示骰子的取值。</p><p><code>dp[i][j][k] -&gt; 投掷第i次骰子, 最后一次投掷出k, 倒数第二次投掷出j时, 合法序列的数目</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MOD</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">distinctSequences</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[][][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][<span class="hljs-number">7</span>][<span class="hljs-number">7</span>];<br>        <span class="hljs-comment">//对n == 1的情况的特判</span><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">6</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//初始化状态数组/状态数组的边界处理 n == 2 的情况</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">7</span>; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">7</span>; ++j) &#123;<br>                <span class="hljs-comment">//如果第一个数与第二个数不相等, 且最大公约数为1</span><br>                <span class="hljs-keyword">if</span> (i != j &amp;&amp; gcd(i, j) == <span class="hljs-number">1</span>) &#123;<br>                    dp[<span class="hljs-number">2</span>][i][j] = <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//填写状态数组/状态转移</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>; i &lt;= n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">7</span>; ++j) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; k &lt; <span class="hljs-number">7</span>; ++k) &#123;<br>                    <span class="hljs-comment">//最后一次的点数与倒数第二次的点数符合要求</span><br>                    <span class="hljs-keyword">if</span> (j != k &amp;&amp; gcd(j, k) == <span class="hljs-number">1</span>) &#123;<br>                        <span class="hljs-comment">//状态转移 枚举当前点k的前第2个点 s j k</span><br>                        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; s &lt; <span class="hljs-number">7</span>; ++s) &#123;<br>                            <span class="hljs-keyword">if</span> (k != s &amp;&amp; s != j &amp;&amp; gcd(j, s) == <span class="hljs-number">1</span>)<br>                                dp[i][j][k] = (dp[i][j][k] + dp[i - <span class="hljs-number">1</span>][s][j]) % MOD;                        <br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//统计结果</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">7</span>; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">7</span>; ++j) &#123;<br>                result = (result + dp[n][i][j]) % MOD;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">//辗转相除法求最大公约数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> b &gt; <span class="hljs-number">0</span> ? gcd(b, a % b) : a;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode 双周赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo图片问题 处理方式1</title>
    <link href="/2022/06/26/Hexo%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98-%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F1/"/>
    <url>/2022/06/26/Hexo%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98-%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F1/</url>
    
    <content type="html"><![CDATA[<h2 id="hexo图片问题-处理方式1">Hexo图片问题 处理方式1</h2><p>初次搭建博客，暂时使用<code>GitHub</code>来做图床，计划后续迁移到七牛云。</p><h2 id="下载picgo">下载<ahref="https://github.com/Molunerfinn/PicGo/releases">PicGo</a></h2><p>下载PicGo用来进行图片上传</p><h2 id="在github中新建一个仓库">在<code>GitHub</code>中新建一个仓库</h2><p>在<code>GitHub</code>中新建一个仓库，用来存放静态资源。仓库的名字可以任意。</p><h2 id="配置picgo">配置PicGo</h2><figure><imgsrc="https://cdn.jsdelivr.net/gh/Chen-SC4/HexoImages/20220626140227.png"alt="Pic配置图片" /><figcaption aria-hidden="true">Pic配置图片</figcaption></figure><ul><li>设定仓库名 填写<code>用户名/仓库名</code></li><li>分支名 默认填写为<code>main</code></li><li>Token用于验证个人身份<ul><li>点击<code>GitHub</code>右上角个人头像 <code>settings</code></li><li>点击左侧菜单最底部的<code>Developer Settings</code><ul><li>点击左侧菜单中的 <code>Personal access tokens</code></li><li>点击 <code>Generate new token</code></li><li><code>Note</code> 中填写<code>token</code>的使用目的</li><li><code>Expiration</code>表示<code>token</code>的有效时间可以选择永久</li><li><code>Select Scope</code>选择第一个<code>repo</code>即可</li></ul></li></ul></li><li>设定自定义域名 该项为可选项<ul><li>如果不填 从国内访问博客 图片加载可能会很慢</li><li>可以填写一个免费的CDN加速<code>https://cdn.jsdelivr.net/gh/GitHub用户名/仓库名</code></li><li><code>jsdelivr</code>有下线的风险，推荐后续将图片资源转移到自己的服务器上</li></ul></li></ul><h2 id="点击确定-配置完成">点击确定 配置完成</h2><p>之后只要截取图片使用<code>PicGo</code>上传，然后选择链接格式，再在<code>相册</code>中找到对应的图片，点击复制链接即可。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/06/25/hello-world/"/>
    <url>/2022/06/25/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <ahref="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <ahref="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
